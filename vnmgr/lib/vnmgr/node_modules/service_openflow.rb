# -*- coding: utf-8 -*-

require 'celluloid'
require 'nio'
require 'trema'
require "trema/dsl/context"
require "trema/util"

module Vnmgr
  module NodeModules

    class OpenflowController < Trema::Controller
      def switch_ready datapath_id
        p "Hello %#x from #{ ARGV[ 0 ] }!" % datapath_id
        shutdown!
      end
    end

    class SwitchManagerWrapper
      include Trema::Util

      def do_cleanup
        cleanup_current_session
      end

      def self.list_bridge_sockets
        # Dcmgr.conf.dc_networks.values.keep_if { |dcn|
        #   dcn.bridge_type == 'ovs' and !dcn.name.empty?
        # }.map { |dcn|
        #   dcn.bridge
        # }.uniq.map { |bridge|
        #   "#{Dcmgr.conf.ovs_run_dir}/#{bridge}.controller"
        # }
        ['/var/run/openvswitch/br0.controller']
      end
    end

    class ServiceOpenflow
      include Celluloid

      def start
        # Trema hack...
        $verbose = true
        # ENV['TREMA_HOME'] = Dcmgr.conf.trema_dir
        # ENV['TREMA_TMP'] = Dcmgr.conf.trema_tmp
        ENV['TREMA_HOME'] = '/opt/axsh/wakame-vdc/ruby/lib/ruby/gems/1.9.1/bundler/gems/trema-ae5c02eca4c1'
        ENV['TREMA_TMP'] = '/var/run/wakame-vnet'

        p "trema: pid_directory:'#{Trema.pid}'."

        SwitchManagerWrapper.new.cleanup_current_session

        Dir.glob(File.join(Trema.pid, "*.pid")).each do | each |
          # logger.info "trema kill: pid_file:'#{each}'."
          p "trema kill: pid_file:'#{each}'."
          pid = IO.read( each ).chomp.to_i
          system("kill #{pid}") if pid != 0
        end

        rule = {
          :port_status => "OpenflowController",
          :packet_in => "OpenflowController",
          :state_notify => "OpenflowController",
          :vendor => "OpenflowController"
        }

        bridge_sockets = SwitchManagerWrapper.list_bridge_sockets
        bridge_sockets.each { |path| FileUtils.remove_file(path, true) }

        raise "No OVS bridges defined." if bridge_sockets.empty?

        # @switch_manager = Trema::SwitchManager.new( rule, nil, bridge_sockets.last )
        @switch_manager = Trema::SwitchManager.new( rule, 6633, nil )
        # @switch_manager.command_prefix = "valgrind -q --tool=memcheck --leak-check=yes --trace-children=yes --log-socket=127.0.0.1:12345 "

        p "Calling: '#{@switch_manager.command}'."

        Thread.new {
          begin
            @@eh = CustomEventHandler.new
            @@eh.set_as_handler

            system(@switch_manager.command)

            self.openflow_controller.init_trema
            self.openflow_controller.run_immediate!
            #self.openflow_controller.run!

            while (true)
              @@eh.run_event_handler_once
            end
          rescue Exception => e
            p e.inspect
          end
        }
      end

      def openflow_controller
        @openflow_controller ||= OpenflowController.new
      end

    end


    #
    # Event handler glue for Trema.
    #

    class EventFdConnection < IO
      attr_accessor :monitor

      def initialize fd, connection
        super(fd)
        @connection = connection
        @monitor = nil
      end

      def notify_readable
        @connection.notify_readable
      end

      def notify_writable
        @connection.notify_writable
      end

      def unbind
        # EM.next_tick do
        #   # socket is detached from the eventloop, but still open
        #   data = @io.read
        # end
      end

      def clear_monitor
        m = self.monitor
        self.monitor = nil
        m
      end

      def change_interest(selector, new_interest)
        old_interest = self.monitor ? self.monitor.interest : nil

        return if old_interest == new_interest
        
        if new_interest == nil
          selector.deregister(self.clear_monitor)
        elsif old_interest == nil
          self.monitor = selector.register(self, new_interest)
        else
          self.monitor.interest = new_interest
        end
      end
    end


    class CustomEventHandler < Trema::EventHandler
      @@selector = NIO::Selector.new
      @@fd_set = []

      def init_event_handler
        p "Called CustomEventHandler init_event_handler."
      end

      def finalize_event_handler
        p "Called CustomEventHandler finalize_event_handler."
        @@selector.close
      end

      def stop_event_handler
        p "Called CustomEventHandler stop_event_handler."
      end

      def run_event_handler_once
        p "Called CustomEventHandler run_event_handler_once."

        @@selector.select(nil).each { |event|
          event.io.notify_readable if event.readable?
          event.io.notify_writable if event.writable?
        }
      end

      def set_fd_handler fd, connection
        p "Called CustomEventHandler immediate set_fd_handler, #{fd}."
        raise "CustomEventHandler event handler already registered." if not @@fd_set[ fd ].nil?

        @@fd_set[fd] = EventFdConnection.new(fd, connection)
      end

      def delete_fd_handler fd
        p "Called CustomEventHandler delete_fd_handler, #{fd}."
        @@fd_set[fd].change_interest(@@selector, nil)
        @@fd_set[fd] = nil
      end

      def set_readable fd, state
        # p "Called CustomEventHandler set_readable, #{fd}."

        if fd < 0
          logger.error "Called set_readable with negative fd: #{fd}, #{state}."
          return
        end

        old_interest = @@fd_set[fd].monitor ? @@fd_set[fd].monitor.interest : nil

        if state
          new_interest = (old_interest == :w || old_interest == :rw) ? :rw : :r
        else
          new_interest = (old_interest == :w || old_interest == :rw) ? :w : nil
        end

        @@fd_set[fd].change_interest(@@selector, new_interest)
      end

      def set_writable fd, state
        # p "Called CustomEventHandler set_writable, #{fd}."

        if fd < 0
          logger.error "Called set_writable with negative fd: #{fd}, #{state}."
          return
        end

        old_interest = @@fd_set[fd].monitor ? @@fd_set[fd].monitor.interest : nil

        if state
          new_interest = (old_interest == :r || old_interest == :rw) ? :rw : :w
        else
          new_interest = (old_interest == :r || old_interest == :rw) ? :r : nil
        end

        @@fd_set[fd].change_interest(@@selector, new_interest)
      end

      def readable fd
        p "Called CustomEventHandler readable, #{fd}."
      end

      def writable fd
        p "Called CustomEventHandler writable, #{fd}."
      end

      # Timer event handlers:
      def init_timer
        p "Called CustomEventHandler init_timer."
      end

      def finalize_timer
        p "Called CustomEventHandler finalize_timer."
      end

      def add_timer_event_callback timer
        p "Called CustomEventHandler: first:#{timer.inspect} interval:#{timer.interval} expiration:#{timer.expiration}."

        # timer.handle.cancel if not timer.handle.nil?

        # # timer.handle = EventMachine::Timer.new(timer.interval) do
        # timer.handle = EventMachine::Timer.new(timer.expiration) do
        #   p "Calling timer event: first:#{timer.inspect} interval:#{timer.interval} expiration:#{timer.expiration}."
        #   timer.call
        # end
      end

      def add_periodic_event_callback interval, timer
        p "Called CustomEventHandler: timer:#{timer.inspect} interval:#{interval}."

        # timer.handle.cancel if not timer.handle.nil?

        # timer.handle = EventMachine::PeriodicTimer.new(interval) do
        #   # p "Calling periodic timer event: timer:#{timer.inspect} interval:#{interval}."
        #   timer.call
        # end
      end

      def delete_timer_event timer
        p "Called CustomEventHandler: timer:#{timer.inspect}."

        # timer.handle.cancel if not timer.handle.nil?
        # timer.handle = nil
      end

      def execute_timer_events
        p "Called CustomEventHandler execute_timer_events."
      end

    end

  end
end
