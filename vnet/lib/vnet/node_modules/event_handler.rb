# -*- coding: utf-8 -*-
module Vnet::NodeModules
  class EventHandler
    include Celluloid
    include Celluloid::Logger
    include Vnet::Event

    attr_accessor :api

    def initialize
      # TODO determin which proxy should be used
      self.api = Vnet::NodeApi.get_proxy(:direct)
      @vna = []
    end

    def handle_event(event, options = {})
      options = options.dup
      debug "handle_event: #{event} options: #{options}"
      case event
      # TODO refactoring
      when "vna_initialized"
        if not @vna.include?({:node => options[:node], :actor => options[:actor]})
          @vna << {:node => options[:node], :actor => options[:actor]}
        else
          error "vna :node = #{options[:node]} actor = #{options[:actor]} is already registered."
        end
      when "network/deleted"
        # TODO refactoring
        # use Vnet::Event
        @vna.each do |v|
          DCell::Node[v[:node]][v[:actor]].async.update_topology(options[:network_id], options[:dpid])
        end
      when ADDED_DATAPATH
        node_id = api.datapath[options[:id]].node_id
        publish_event(node_id, event, options)
      when REMOVED_DATAPATH
        node_id = api.datapath.with_deleted.first(id: options[:id]).node_id
        publish_event(node_id, event, options)
      else
        api.datapath.find_all.map(&:node_id).uniq.each do |node_id|
          publish_event(node_id, event, options)
        end
      end
    end

    def publish_event(node_id, event, options)
      debug "publish_event #{event} #{options}"
      DCell::Node[node_id].tap do |node|
        unless node && node.state == :connected
          warn "node: #{node_id} is disconnected"
          next
        end
        node[:service_openflow].publish(event, options)
      end
    end
  end
end
