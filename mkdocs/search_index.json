{
    "docs": [
        {
            "location": "/",
            "text": "What is OpenVNet?\n\n\nOpenVNet is what you would call a network hypervisor or \nsoftware-defined networking\n. It is basically is to networking what virtual machines are to servers. Network engineers become able to create any network topology that they have in mind, without changing the hardware that's in place. Visit the \nOpenVNet concept\n page to learn more.\n\n\nOpenVNet is free open source software. The source is \nfreely available on Github\n. Everybody is welcome to contribute to development and the software can be freely distributed. (Within the rules of the LGPL license)\n\n\nGetting started\n\n\nInstallation Guide\n\n\nThis guide will teach you how to set up a basic OpenVNet environment with two VMs on the same host connected to \nOpen vSwitch\n. It is a great entry point into the world of OpenVNet.\n\n\nWe hope to get more expansive guides up in the future. Until then we encourage you to play around and contact us for assistance if needed.\n\n\nContact us\n\n\nThe best way to contact us is to send an e-mail to the \nWakame Users Group\n on Google Groups. Please don't hesitate to ask us any questions. OpenVNet can be a little difficult to grasp in the beginning. If you want to try it out, we'll do our best to help you.\n\n\nIf you happen to be in Tokyo, you can also attend one of our Wakame Users Group events. They are open to everybody. Further details on http://wakameusersgroup.org.",
            "title": "Home"
        },
        {
            "location": "/#what-is-openvnet",
            "text": "OpenVNet is what you would call a network hypervisor or  software-defined networking . It is basically is to networking what virtual machines are to servers. Network engineers become able to create any network topology that they have in mind, without changing the hardware that's in place. Visit the  OpenVNet concept  page to learn more.  OpenVNet is free open source software. The source is  freely available on Github . Everybody is welcome to contribute to development and the software can be freely distributed. (Within the rules of the LGPL license)",
            "title": "What is OpenVNet?"
        },
        {
            "location": "/#getting-started",
            "text": "Installation Guide  This guide will teach you how to set up a basic OpenVNet environment with two VMs on the same host connected to  Open vSwitch . It is a great entry point into the world of OpenVNet.  We hope to get more expansive guides up in the future. Until then we encourage you to play around and contact us for assistance if needed.",
            "title": "Getting started"
        },
        {
            "location": "/#contact-us",
            "text": "The best way to contact us is to send an e-mail to the  Wakame Users Group  on Google Groups. Please don't hesitate to ask us any questions. OpenVNet can be a little difficult to grasp in the beginning. If you want to try it out, we'll do our best to help you.  If you happen to be in Tokyo, you can also attend one of our Wakame Users Group events. They are open to everybody. Further details on http://wakameusersgroup.org.",
            "title": "Contact us"
        },
        {
            "location": "/concept/",
            "text": "Concept\n\n\nOpenVNet is what you would call a network hypervisor or \nsoftware-defined networking\n. A network hypervisor provides a layer of abstraction on top of existing network hardware. It is basically is to networking what virtual machines are to servers.\n\n\n\n\nOnce OpenVNet has been set up, it becomes possible to create any network topology that you have in mind, without making any changes to the hardware.\n\n\nOpenVNet is completely independent of hardware. The only requirement is that hypervisor hosts have IP connectivity to each other.\n\n\nUsers can tell OpenVNet what to do by accessing its Web API. This API provides a single endpoint through which you can create simulated network devices like routers, firewalls, DHCP servers, etc. Virtual Machines, or rather their network interfaces, can then be attached to any of these virtual networks. The resulting network topology can be re-arranged on the fly.\n\n\nUnder the Hood\n\n\n\n\nOpenVNet builds on top of \nOpenFlow\n. In short, OpenFlow is an open protocol that can be used to tell network devices like switches or routers what to do. OpenVNet uses OpenFlow to communicate with Open vSwitch.\n\n\nHypervisor host\n\n\nThis is a server running Linux that will start virtual machines which will then be placed in OpenVNet's virtual networks. OpenVNet can work with any hypervisor as long as the virtual machines' network interfaces can be attached to Open vSwitch. Starting the virtual machines themselves is beyond the scope of OpenVNet. It can be done manually or through integration with \nWakame-vdc\n. Other custom solutions are always possible and Axsh is available for hire to help implement them.\n\n\nWhile most OpenVNet environments will consist of only virtual machines, it is possible to place bare metal servers in virtual networks. Their network cards can be added to Open vSwitch in the same way virtual machines are.\n\n\nBelow we will explain OpenVNet's different components one by one.\n\n\nOpen vSwitch\n\n\nOpen vSwitch\n is a Linux kernel module that acts as a network switch for virtual machines. Because this switch has implemented OpenFlow, OpenVNet is able to change its \nflow tables\n on the fly. These flow tables are essentially a set of rules that decide what needs to happen as network traffic is processed. It is through manipulating these that software defined networking can be implemented.\n\n\nVNA\n\n\nThe \nVirtual Network Agent\n, or VNA for short, is the OpenFlow controller that tells Open vSwitch to alter its flow tables. In order to prevent a single point of failure, OpenVNet has a dedicated VNA for every hypervisor host running Open vSwitch.\n\n\nVnmgr\n\n\nThe \nVirtual Network Manager\n or Vnmgr acts as OpenVNet's database front-end and decision making organ. As the user changes the virtual network topology through OpenVNet's Web API, Vnmgr stores the new topology in the database and broadcasts events to all affected VNAs, informing them of the changes they need to make.\n\n\nDatabase\n\n\nThe database stores a representation of the current network topology. Vnmgr is responsible for maintaining/updating it and sending relevant information to the VNA on each hypervisor host.\n\n\nWeb API\n\n\nThis is the endpoint through which users can talk to OpenVNet. By sending HTTP requests to this API, the virtual network topology can be changed.\n\n\nVnctl\n\n\nThis is a commandline interface that makes accessing the Web API just a little more convenient.\n\n\nUser Laptop\n\n\nThis is the client machine from which the user sends requests to the Web API. We use the word laptop to make clear that this device does not need to be running anything special. Any device that can make HTTP calls will do.\n\n\nVNet Edge\n\n\nAs the name might imply, this is the edge of VNet's virtual network topology. VNet Edge provides Layer 2 interconnectivity between OpenVNet's virtual networks and any other network.\n\n\nPhysical Network\n\n\nThis is the network that provides connectivity between hypervisor hosts and the servers running Vnmgr, Web API and the database. It doesn't matter what hardware this is run on. As long as all hosts have TCP/IP access to each other, OpenVNet will work.",
            "title": "Concept"
        },
        {
            "location": "/concept/#concept",
            "text": "OpenVNet is what you would call a network hypervisor or  software-defined networking . A network hypervisor provides a layer of abstraction on top of existing network hardware. It is basically is to networking what virtual machines are to servers.   Once OpenVNet has been set up, it becomes possible to create any network topology that you have in mind, without making any changes to the hardware.  OpenVNet is completely independent of hardware. The only requirement is that hypervisor hosts have IP connectivity to each other.  Users can tell OpenVNet what to do by accessing its Web API. This API provides a single endpoint through which you can create simulated network devices like routers, firewalls, DHCP servers, etc. Virtual Machines, or rather their network interfaces, can then be attached to any of these virtual networks. The resulting network topology can be re-arranged on the fly.",
            "title": "Concept"
        },
        {
            "location": "/concept/#under-the-hood",
            "text": "OpenVNet builds on top of  OpenFlow . In short, OpenFlow is an open protocol that can be used to tell network devices like switches or routers what to do. OpenVNet uses OpenFlow to communicate with Open vSwitch.",
            "title": "Under the Hood"
        },
        {
            "location": "/concept/#hypervisor-host",
            "text": "This is a server running Linux that will start virtual machines which will then be placed in OpenVNet's virtual networks. OpenVNet can work with any hypervisor as long as the virtual machines' network interfaces can be attached to Open vSwitch. Starting the virtual machines themselves is beyond the scope of OpenVNet. It can be done manually or through integration with  Wakame-vdc . Other custom solutions are always possible and Axsh is available for hire to help implement them.  While most OpenVNet environments will consist of only virtual machines, it is possible to place bare metal servers in virtual networks. Their network cards can be added to Open vSwitch in the same way virtual machines are.  Below we will explain OpenVNet's different components one by one.",
            "title": "Hypervisor host"
        },
        {
            "location": "/concept/#open-vswitch",
            "text": "Open vSwitch  is a Linux kernel module that acts as a network switch for virtual machines. Because this switch has implemented OpenFlow, OpenVNet is able to change its  flow tables  on the fly. These flow tables are essentially a set of rules that decide what needs to happen as network traffic is processed. It is through manipulating these that software defined networking can be implemented.",
            "title": "Open vSwitch"
        },
        {
            "location": "/concept/#vna",
            "text": "The  Virtual Network Agent , or VNA for short, is the OpenFlow controller that tells Open vSwitch to alter its flow tables. In order to prevent a single point of failure, OpenVNet has a dedicated VNA for every hypervisor host running Open vSwitch.",
            "title": "VNA"
        },
        {
            "location": "/concept/#vnmgr",
            "text": "The  Virtual Network Manager  or Vnmgr acts as OpenVNet's database front-end and decision making organ. As the user changes the virtual network topology through OpenVNet's Web API, Vnmgr stores the new topology in the database and broadcasts events to all affected VNAs, informing them of the changes they need to make.",
            "title": "Vnmgr"
        },
        {
            "location": "/concept/#database",
            "text": "The database stores a representation of the current network topology. Vnmgr is responsible for maintaining/updating it and sending relevant information to the VNA on each hypervisor host.",
            "title": "Database"
        },
        {
            "location": "/concept/#web-api",
            "text": "This is the endpoint through which users can talk to OpenVNet. By sending HTTP requests to this API, the virtual network topology can be changed.",
            "title": "Web API"
        },
        {
            "location": "/concept/#vnctl",
            "text": "This is a commandline interface that makes accessing the Web API just a little more convenient.",
            "title": "Vnctl"
        },
        {
            "location": "/concept/#user-laptop",
            "text": "This is the client machine from which the user sends requests to the Web API. We use the word laptop to make clear that this device does not need to be running anything special. Any device that can make HTTP calls will do.",
            "title": "User Laptop"
        },
        {
            "location": "/concept/#vnet-edge",
            "text": "As the name might imply, this is the edge of VNet's virtual network topology. VNet Edge provides Layer 2 interconnectivity between OpenVNet's virtual networks and any other network.",
            "title": "VNet Edge"
        },
        {
            "location": "/concept/#physical-network",
            "text": "This is the network that provides connectivity between hypervisor hosts and the servers running Vnmgr, Web API and the database. It doesn't matter what hardware this is run on. As long as all hosts have TCP/IP access to each other, OpenVNet will work.",
            "title": "Physical Network"
        },
        {
            "location": "/features/",
            "text": "Feature list\n\n\n\n\nTwo protocols to support virtual networking.\n\n\n\n\n\n\nMAC2MAC\n (Axsh original protocol for physical L2 tunneling)\n\n\n\n\n\n\n\n\n\n\nGRE\n (protocol for L3 tunneling)\n\n\n\n\n\n\nSimulated DHCP service\n\n\nSimulated DNS service\n\n\nL3 routing between virtual networks.\n\n\nSingle hop L3 routing between physical and virtual networks.\n\n\nFirewall (security groups)\n\n\nConnection tracking\n\n\nOne to one static network address translation. (SNAT)\n\n\nVNet Edge feature (connect virtual and physical networks)\n\n\nRESTful Web API\n\n\nCommandline interface (vnctl) for calling the Web API.\n\n\nIntegration with \nWakame-vdc\n.\n\n\nA \nRuby library (gem)\n that will allow you to call the Web API directly from ruby applications.",
            "title": "Features"
        },
        {
            "location": "/features/#feature-list",
            "text": "Two protocols to support virtual networking.    MAC2MAC  (Axsh original protocol for physical L2 tunneling)      GRE  (protocol for L3 tunneling)    Simulated DHCP service  Simulated DNS service  L3 routing between virtual networks.  Single hop L3 routing between physical and virtual networks.  Firewall (security groups)  Connection tracking  One to one static network address translation. (SNAT)  VNet Edge feature (connect virtual and physical networks)  RESTful Web API  Commandline interface (vnctl) for calling the Web API.  Integration with  Wakame-vdc .  A  Ruby library (gem)  that will allow you to call the Web API directly from ruby applications.",
            "title": "Feature list"
        },
        {
            "location": "/installation/",
            "text": "OpenVNet Installation Guide\n\n\nOverview\n\n\nWelcome to the world of OpenVNet! With this installation guide we help you\ncreate a very simple yet innovative virtual network environment.\n\n\nIn this guide we are going to install all of OpenVNet's services into a single machine running CentOS. This can be a virtual machine. Afterwards we are going to use LXC to set up two containers that we'll connect to OpenVNet's virtual networks.\n\n\n\n\nRequirements\n\n\n\n\nCentOS 6\n\n\nInternet connection\n\n\n\n\nInstallation\n\n\nInstall OpenVNet Packages\n\n\nDownload the openvnet.repo file and put it to your \n/etc/yum.repos.d/\n directory.\n\n\ncurl -o /etc/yum.repos.d/openvnet.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet.repo\n\n\n\n\nDownload the openvnet-third-party.repo file and put it in your \n/etc/yum.repos.d/\n directory.\n\n\ncurl -o /etc/yum.repos.d/openvnet-third-party.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet-third-party.repo\n\n\n\n\nEach repo has the following packages:\n\n\nopenvnet.repo\n\n\n\n\nopenvnet (metapackage)\n\n\nopenvnet-common\n\n\nopenvnet-vna\n\n\nopenvnet-vnmgr\n\n\nopenvnet-webapi\n\n\nopenvnet-vnctl\n\n\n\n\nopenvnet-third-party.repo\n\n\n\n\nopenvnet-ruby\n\n\nopenvswitch\n\n\n\n\nInstall epel-release.\n\n\nyum install -y epel-release\n\n\n\n\nInstall OpenVNet packages.\n\n\nyum install -y openvnet\n\n\n\n\nopenvnet\n is an metapackage that depends on \nopenvnet-common\n, \nopenvnet-vna\n, \nopenvnet-vnmgr\n, \nopenvnet-webapi\n and \nopenvnet-vnctl\n. It's just a convenient way to install all of those at once.\n\n\nInstall \nRedis\n and \nMySQL server\n. Redis is required for OpenVNet's processes to communicate and MySQL is used to store the network state.\n\n\nThough they're both required, they are not package dependencies because OpenVNet is distributed software. In a production environment, it is very likely for these packages to be installed on other machines than the OpenVNet processes themselves.\n\n\nyum install -y mysql-server redis\n\n\n\n\nSetup Open vSwitch\n\n\nWe are going to create a bridge \nbr0\n using Open vSwitch. Later we will attach our VMs \ninst1\n and \ninst2\n to this bridge.\n\n\nCreate the file \n/etc/sysconfig/network-scripts/ifcfg-br0\n with the following contents.\n\n\nDEVICE=br0\nDEVICETYPE=ovs\nTYPE=OVSBridge\nONBOOT=yes\nBOOTPROTO=static\nHOTPLUG=no\nOVS_EXTRA=\"\n set bridge     ${DEVICE} protocols=OpenFlow10,OpenFlow12,OpenFlow13 --\n set bridge     ${DEVICE} other_config:disable-in-band=true --\n set bridge     ${DEVICE} other-config:datapath-id=0000aaaaaaaaaaaa --\n set bridge     ${DEVICE} other-config:hwaddr=02:01:00:00:00:01 --\n set-fail-mode  ${DEVICE} secure --\n set-controller ${DEVICE} tcp:127.0.0.1:6633\n\"\n\n\n\n\nRemark:\n Notice how we set the \ndatapath-id\n to \n0000aaaaaaaaaaaa\n? This is a unique ID that OpenVNet will use to recognise this bridge later. You can set it to any 16 hex digits of your choosing but make sure to remember it for later.\n\n\nStart the \nopenvswitch\n service and bring  up the bridge.\n\n\nservice openvswitch start\nifup br0\n\n\n\n\nSetup Database\n\n\nLaunch the MySQL server.\n\n\nservice mysqld start\n\n\n\n\nOpenVNet uses its own ruby binary. We need to add it to the \nPATH\n variable so we can call bundle in the next step.\n\n\nPATH=/opt/axsh/openvnet/ruby/bin:${PATH}\n\n\n\n\nCreate database\n\n\ncd /opt/axsh/openvnet/vnet\nbundle exec rake db:create\nbundle exec rake db:init\n\n\n\n\nStart redis\n\n\nAs mentioned above, OpenVNet services require redis to communicate with each other. Start it.\n\n\nservice redis start\n\n\n\n\nStart OpenVNet services\n\n\nStarting the OpenVNet services will create log files in the \n/var/log/openvnet\n directory. If anything goes wrong, you might find useful error messages in them.\n\n\nStart vnmgr and webapi.\n\n\ninitctl start vnet-vnmgr\ninitctl start vnet-webapi\n\n\n\n\nWe use \nvnctl\n to create the database records subsequent to the above configurations. \nvnctl\n is a Web API client offered by the \nopenvnet-vnctl\n package.\n\n\nDatapath\n\n\nRemember the \ndatapath-id\n we set when setting up Open vSwitch? The following command will tell OpenVNet that VNA needs to manage this datapath.\n\n\nvnctl datapaths add --uuid dp-test1 --display-name test1 --dpid 0x0000aaaaaaaaaaaa --node-id vna\n\n\n\n\nMac Address Range\n\n\nIn order for the network overlay to work, OpenVNet uses mac addresses independently of any real or virtual interface. To allocate these it requires the creation of a default mac range group.\n\n\nvnctl mac_range_groups add --uuid mrg-dpg\n\n\n\n\nIn \ncommon.conf\n, the mac range group is set by default to \nmrg-dpg\n and can be changed using the \ndatapath_mac_group\n option.\n\n\nvnctl mac_range_groups mac_ranges add mrg-dpg --begin_mac_address 52:56:01:00:00:00 --end_mac_address 52:56:01:ff:ff:ff\n\n\n\n\n\n\n\n\nbegin_mac_address\n : The lowest possible mac address value in the range.\n\n\n\n\n\n\nend_mac_address\n : The highest possible mac address value in the range.\n\n\n\n\n\n\nNow let's start vna.\n\n\ninitctl start vnet-vna\n\n\n\n\nYou can run \novs-vsctl show\n to check if vna is working correctly.\n\n\nYou should be able to see \nis_connected: true\n in its output. If it doesn't appear right away, wait a few seconds and then try again. If it still doesn't appear, something went wrong and you should have a look at \n/var/log/openvnet/vna.log\n for errors.\n\n\nfbe23184-7f14-46cb-857b-3abf6153a6d6\n    Bridge \"br0\"\n        Controller \"tcp:127.0.0.1:6633\"\n            is_connected: true\n\n\n\n\nLXC Setup\n\n\nWe now have OpenVNet set up and working but we don't have any virtual machines connected to it yet. In this step we are going to use \nLXC\n to create the two containers (guests) \ninst1\n and \ninst2\n that will be connected to OpenVNet's virtual networks.\n\n\nAny virtualization techonology will work but in this guide we're using LXC because it's lightweight and can easily be set up inside virtual machines as well.\n\n\nInstall LXC\n\n\nyum -y install lxc lxc-templates\n\n\n\n\nCreate and mount cgroup\n\n\nmkdir /cgroup\necho \"cgroup /cgroup cgroup defaults 0 0\" >> /etc/fstab\nmount /cgroup\n\n\n\n\nCreate 2 LXC guests\n\n\nRsync is required for this. If it's not installed already, install it with the following command.\n\n\nyum install -y rsync\n\n\n\n\nlxc-create -t centos -n inst1\nlxc-create -t centos -n inst2\n\n\n\n\nThese commands' output will tell you were to find or set the root password for \ninst1\n and \ninst2\n. Make sure set it and remember it for later. You're going to need it to log into them.\n\n\nApply Network interface settings\n\n\nOpen the file \n/var/lib/lxc/inst1/config\n and replace its contents with the following.\n\n\nlxc.network.type = veth\nlxc.network.flags = up\nlxc.network.veth.pair = inst1\nlxc.network.hwaddr = 10:54:FF:00:00:01\nlxc.rootfs = /var/lib/lxc/inst1/rootfs\nlxc.include = /usr/share/lxc/config/centos.common.conf\nlxc.arch = x86_64\nlxc.utsname = inst1\nlxc.autodev = 0\n\n\n\n\nOpen the file \n/var/lib/lxc/inst2/config\n and replace its contents with the following.\n\n\nlxc.network.type = veth\nlxc.network.flags = up\nlxc.network.veth.pair = inst2\nlxc.network.hwaddr = 10:54:FF:00:00:02\nlxc.rootfs = /var/lib/lxc/inst2/rootfs\nlxc.include = /usr/share/lxc/config/centos.common.conf\nlxc.arch = x86_64\nlxc.utsname = inst2\nlxc.autodev = 0\n\n\n\n\nRemark:\n We do not use \nlxc.network.link\n parameter because the Linux bridge is replaced by the Open vSwitch. That parameter expects to interface with the Linux bridge and containers will fail to start if you attempt to use it with Open vSwitch. We'll enslave the tap interfaces manually in the next step.\n\n\nStart the LXC guests\n\n\nlxc-start -d -n inst1\nlxc-start -d -n inst2\n\n\n\n\nAttach them to Open vSwitch\n\n\novs-vsctl add-port br0 inst1\novs-vsctl add-port br0 inst2\n\n\n\n\nNow the LXC's network interfaces are attached to the Open vSwitch. This is basically the same as plugging a network cable into a physical switch.\n\n\nCongratulations. You have now installed OpenVNet and you're ready to start building your first virtual network. We recommend you start with the simplest possible setting: \nSingle Network\n.",
            "title": "Installation"
        },
        {
            "location": "/installation/#openvnet-installation-guide",
            "text": "",
            "title": "OpenVNet Installation Guide"
        },
        {
            "location": "/installation/#overview",
            "text": "Welcome to the world of OpenVNet! With this installation guide we help you\ncreate a very simple yet innovative virtual network environment.  In this guide we are going to install all of OpenVNet's services into a single machine running CentOS. This can be a virtual machine. Afterwards we are going to use LXC to set up two containers that we'll connect to OpenVNet's virtual networks.",
            "title": "Overview"
        },
        {
            "location": "/installation/#requirements",
            "text": "CentOS 6  Internet connection",
            "title": "Requirements"
        },
        {
            "location": "/installation/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/installation/#install-openvnet-packages",
            "text": "Download the openvnet.repo file and put it to your  /etc/yum.repos.d/  directory.  curl -o /etc/yum.repos.d/openvnet.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet.repo  Download the openvnet-third-party.repo file and put it in your  /etc/yum.repos.d/  directory.  curl -o /etc/yum.repos.d/openvnet-third-party.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet-third-party.repo  Each repo has the following packages:",
            "title": "Install OpenVNet Packages"
        },
        {
            "location": "/installation/#openvnetrepo",
            "text": "openvnet (metapackage)  openvnet-common  openvnet-vna  openvnet-vnmgr  openvnet-webapi  openvnet-vnctl",
            "title": "openvnet.repo"
        },
        {
            "location": "/installation/#openvnet-third-partyrepo",
            "text": "openvnet-ruby  openvswitch   Install epel-release.  yum install -y epel-release  Install OpenVNet packages.  yum install -y openvnet  openvnet  is an metapackage that depends on  openvnet-common ,  openvnet-vna ,  openvnet-vnmgr ,  openvnet-webapi  and  openvnet-vnctl . It's just a convenient way to install all of those at once.  Install  Redis  and  MySQL server . Redis is required for OpenVNet's processes to communicate and MySQL is used to store the network state.  Though they're both required, they are not package dependencies because OpenVNet is distributed software. In a production environment, it is very likely for these packages to be installed on other machines than the OpenVNet processes themselves.  yum install -y mysql-server redis",
            "title": "openvnet-third-party.repo"
        },
        {
            "location": "/installation/#setup-open-vswitch",
            "text": "We are going to create a bridge  br0  using Open vSwitch. Later we will attach our VMs  inst1  and  inst2  to this bridge.  Create the file  /etc/sysconfig/network-scripts/ifcfg-br0  with the following contents.  DEVICE=br0\nDEVICETYPE=ovs\nTYPE=OVSBridge\nONBOOT=yes\nBOOTPROTO=static\nHOTPLUG=no\nOVS_EXTRA=\"\n set bridge     ${DEVICE} protocols=OpenFlow10,OpenFlow12,OpenFlow13 --\n set bridge     ${DEVICE} other_config:disable-in-band=true --\n set bridge     ${DEVICE} other-config:datapath-id=0000aaaaaaaaaaaa --\n set bridge     ${DEVICE} other-config:hwaddr=02:01:00:00:00:01 --\n set-fail-mode  ${DEVICE} secure --\n set-controller ${DEVICE} tcp:127.0.0.1:6633\n\"  Remark:  Notice how we set the  datapath-id  to  0000aaaaaaaaaaaa ? This is a unique ID that OpenVNet will use to recognise this bridge later. You can set it to any 16 hex digits of your choosing but make sure to remember it for later.  Start the  openvswitch  service and bring  up the bridge.  service openvswitch start\nifup br0",
            "title": "Setup Open vSwitch"
        },
        {
            "location": "/installation/#setup-database",
            "text": "Launch the MySQL server.  service mysqld start  OpenVNet uses its own ruby binary. We need to add it to the  PATH  variable so we can call bundle in the next step.  PATH=/opt/axsh/openvnet/ruby/bin:${PATH}  Create database  cd /opt/axsh/openvnet/vnet\nbundle exec rake db:create\nbundle exec rake db:init",
            "title": "Setup Database"
        },
        {
            "location": "/installation/#start-redis",
            "text": "As mentioned above, OpenVNet services require redis to communicate with each other. Start it.  service redis start",
            "title": "Start redis"
        },
        {
            "location": "/installation/#start-openvnet-services",
            "text": "Starting the OpenVNet services will create log files in the  /var/log/openvnet  directory. If anything goes wrong, you might find useful error messages in them.  Start vnmgr and webapi.  initctl start vnet-vnmgr\ninitctl start vnet-webapi  We use  vnctl  to create the database records subsequent to the above configurations.  vnctl  is a Web API client offered by the  openvnet-vnctl  package.",
            "title": "Start OpenVNet services"
        },
        {
            "location": "/installation/#datapath",
            "text": "Remember the  datapath-id  we set when setting up Open vSwitch? The following command will tell OpenVNet that VNA needs to manage this datapath.  vnctl datapaths add --uuid dp-test1 --display-name test1 --dpid 0x0000aaaaaaaaaaaa --node-id vna",
            "title": "Datapath"
        },
        {
            "location": "/installation/#mac-address-range",
            "text": "In order for the network overlay to work, OpenVNet uses mac addresses independently of any real or virtual interface. To allocate these it requires the creation of a default mac range group.  vnctl mac_range_groups add --uuid mrg-dpg  In  common.conf , the mac range group is set by default to  mrg-dpg  and can be changed using the  datapath_mac_group  option.  vnctl mac_range_groups mac_ranges add mrg-dpg --begin_mac_address 52:56:01:00:00:00 --end_mac_address 52:56:01:ff:ff:ff    begin_mac_address  : The lowest possible mac address value in the range.    end_mac_address  : The highest possible mac address value in the range.    Now let's start vna.  initctl start vnet-vna  You can run  ovs-vsctl show  to check if vna is working correctly.  You should be able to see  is_connected: true  in its output. If it doesn't appear right away, wait a few seconds and then try again. If it still doesn't appear, something went wrong and you should have a look at  /var/log/openvnet/vna.log  for errors.  fbe23184-7f14-46cb-857b-3abf6153a6d6\n    Bridge \"br0\"\n        Controller \"tcp:127.0.0.1:6633\"\n            is_connected: true",
            "title": "Mac Address Range"
        },
        {
            "location": "/installation/#lxc-setup",
            "text": "We now have OpenVNet set up and working but we don't have any virtual machines connected to it yet. In this step we are going to use  LXC  to create the two containers (guests)  inst1  and  inst2  that will be connected to OpenVNet's virtual networks.  Any virtualization techonology will work but in this guide we're using LXC because it's lightweight and can easily be set up inside virtual machines as well.",
            "title": "LXC Setup"
        },
        {
            "location": "/installation/#install-lxc",
            "text": "yum -y install lxc lxc-templates",
            "title": "Install LXC"
        },
        {
            "location": "/installation/#create-and-mount-cgroup",
            "text": "mkdir /cgroup\necho \"cgroup /cgroup cgroup defaults 0 0\" >> /etc/fstab\nmount /cgroup",
            "title": "Create and mount cgroup"
        },
        {
            "location": "/installation/#create-2-lxc-guests",
            "text": "Rsync is required for this. If it's not installed already, install it with the following command.  yum install -y rsync  lxc-create -t centos -n inst1\nlxc-create -t centos -n inst2  These commands' output will tell you were to find or set the root password for  inst1  and  inst2 . Make sure set it and remember it for later. You're going to need it to log into them.",
            "title": "Create 2 LXC guests"
        },
        {
            "location": "/installation/#apply-network-interface-settings",
            "text": "Open the file  /var/lib/lxc/inst1/config  and replace its contents with the following.  lxc.network.type = veth\nlxc.network.flags = up\nlxc.network.veth.pair = inst1\nlxc.network.hwaddr = 10:54:FF:00:00:01\nlxc.rootfs = /var/lib/lxc/inst1/rootfs\nlxc.include = /usr/share/lxc/config/centos.common.conf\nlxc.arch = x86_64\nlxc.utsname = inst1\nlxc.autodev = 0  Open the file  /var/lib/lxc/inst2/config  and replace its contents with the following.  lxc.network.type = veth\nlxc.network.flags = up\nlxc.network.veth.pair = inst2\nlxc.network.hwaddr = 10:54:FF:00:00:02\nlxc.rootfs = /var/lib/lxc/inst2/rootfs\nlxc.include = /usr/share/lxc/config/centos.common.conf\nlxc.arch = x86_64\nlxc.utsname = inst2\nlxc.autodev = 0  Remark:  We do not use  lxc.network.link  parameter because the Linux bridge is replaced by the Open vSwitch. That parameter expects to interface with the Linux bridge and containers will fail to start if you attempt to use it with Open vSwitch. We'll enslave the tap interfaces manually in the next step.",
            "title": "Apply Network interface settings"
        },
        {
            "location": "/installation/#start-the-lxc-guests",
            "text": "lxc-start -d -n inst1\nlxc-start -d -n inst2",
            "title": "Start the LXC guests"
        },
        {
            "location": "/installation/#attach-them-to-open-vswitch",
            "text": "ovs-vsctl add-port br0 inst1\novs-vsctl add-port br0 inst2  Now the LXC's network interfaces are attached to the Open vSwitch. This is basically the same as plugging a network cable into a physical switch.  Congratulations. You have now installed OpenVNet and you're ready to start building your first virtual network. We recommend you start with the simplest possible setting:  Single Network .",
            "title": "Attach them to Open vSwitch"
        },
        {
            "location": "/upgrade/",
            "text": "OpenVNet upgrade guide\n\n\nThis guide details the steps requires when upgrading from an older version of OpenVNet.\n\n\nTurn off all OpenVNet services\n\n\nstop vnet-webapi\nstop vnet-vnmgr\nstop vnet-vna\n\n\n\n\nUpdate OpenVNet through yum.\n\n\nyum update\n\n\n\n\nMigrate the database to the latest version.\n\n\nIt's likely that the database had added new tables in the new version. Update it.\n\n\nPATH=/opt/axsh/openvnet/ruby/bin:${PATH}\ncd /opt/axsh/openvnet/vnet\nbundle exec rake db:migrate\n\n\n\n\nAdditional steps\n\n\nSome additional steps may be required if you are upgrading to a specific version.\n\n\nVersion 0.9\n\n\nVersion 0.9 added functionality for automatically creating \ndatapath_network\n and \ndatapath_route_link\n entries in the database.\n\n\nThis requires OpenVNet to automatically assign MAC address values for these. When upgrading to version 0.9 it is required to provide OpenVNet with a range of MAC addresses it is allowed to assign.\n\n\nvnctl mac_range_groups add --uuid mrg-dpg\nvnctl mac_range_groups mac_ranges add mrg-dpg --begin_mac_address 52:56:01:00:00:00 --end_mac_address 52:56:01:ff:ff:ff\n\n\n\n\nRemark:\n If a different UUID than \nmrg-dpg\n is used, you must open \n/etc/openvnet/common.conf\n and edit the following line. \ndatapath_mac_group \"mrg-dpg\"\n\n\nStart OpenVNet services\n\n\nstart vnet-webapi\nstart vnet-vnmgr\nstart vnet-vna",
            "title": "Upgrading"
        },
        {
            "location": "/upgrade/#openvnet-upgrade-guide",
            "text": "This guide details the steps requires when upgrading from an older version of OpenVNet.",
            "title": "OpenVNet upgrade guide"
        },
        {
            "location": "/upgrade/#turn-off-all-openvnet-services",
            "text": "stop vnet-webapi\nstop vnet-vnmgr\nstop vnet-vna",
            "title": "Turn off all OpenVNet services"
        },
        {
            "location": "/upgrade/#update-openvnet-through-yum",
            "text": "yum update",
            "title": "Update OpenVNet through yum."
        },
        {
            "location": "/upgrade/#migrate-the-database-to-the-latest-version",
            "text": "It's likely that the database had added new tables in the new version. Update it.  PATH=/opt/axsh/openvnet/ruby/bin:${PATH}\ncd /opt/axsh/openvnet/vnet\nbundle exec rake db:migrate",
            "title": "Migrate the database to the latest version."
        },
        {
            "location": "/upgrade/#additional-steps",
            "text": "Some additional steps may be required if you are upgrading to a specific version.",
            "title": "Additional steps"
        },
        {
            "location": "/upgrade/#version-09",
            "text": "Version 0.9 added functionality for automatically creating  datapath_network  and  datapath_route_link  entries in the database.  This requires OpenVNet to automatically assign MAC address values for these. When upgrading to version 0.9 it is required to provide OpenVNet with a range of MAC addresses it is allowed to assign.  vnctl mac_range_groups add --uuid mrg-dpg\nvnctl mac_range_groups mac_ranges add mrg-dpg --begin_mac_address 52:56:01:00:00:00 --end_mac_address 52:56:01:ff:ff:ff  Remark:  If a different UUID than  mrg-dpg  is used, you must open  /etc/openvnet/common.conf  and edit the following line.  datapath_mac_group \"mrg-dpg\"",
            "title": "Version 0.9"
        },
        {
            "location": "/upgrade/#start-openvnet-services",
            "text": "start vnet-webapi\nstart vnet-vnmgr\nstart vnet-vna",
            "title": "Start OpenVNet services"
        },
        {
            "location": "/creating-virtual-networks/single-network/",
            "text": "Single network\n\n\nOverview\n\n\nThis is the simplest possible setup after completing the \ninstallation guide\n. It's a great start for when you're just getting into OpenVNet.\n\n\nThis document expects you to have set up OpenVNet according to the installation guide. We will be referring to the VMs \ninst1\n and \ninst2\n as they've been set up in there.\n\n\nWe are going to use them to create the following virtual network topology.\n\n\n\n\nWe will just have one simple network: \n10.100.0.0/24\n.\n\n\n\n\nInst1\n's IP address: \n10.100.0.10\n\n\nInst2\n's IP address: \n10.100.0.11\n\n\n\n\nSetup\n\n\nCreate the network\n\n\nvnctl networks add \\\n  --uuid nw-test1 \\\n  --display-name testnet1 \\\n  --ipv4-network 10.100.0.0 \\\n  --ipv4-prefix 24 \\\n  --network-mode virtual\n\n\n\n\nSet up the interfaces\n\n\nNow that we have a virtual network, we need to tell OpenVNet which interfaces are in it and which IP addresses they will get. We need to do this for both \ninst1\n and \ninst2\n.\n\n\nvnctl interfaces add \\\n  --uuid if-inst1 \\\n  --mode vif \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 10:54:ff:00:00:01 \\\n  --network-uuid nw-test1 \\\n  --ipv4-address 10.100.0.10 \\\n  --port-name inst1\n\nvnctl interfaces add \\\n  --uuid if-inst2 \\\n  --mode vif \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 10:54:ff:00:00:02 \\\n  --network-uuid nw-test1 \\\n  --ipv4-address 10.100.0.11 \\\n  --port-name inst2\n\n\n\n\nFor more information about the interfaces commands, visit \ntheir section\n in the Vnctl documentation.\n\n\nTest\n\n\nLog into \ninst1\n and check its IP address configuration.\n\n\nlxc-console -n inst1\nip a\n\n\n\n\nIf everything went well you will see that it has no IP address assigned to it. That is to be expected. The network we have just set up does not have a DHCP server. Assign the IP address manually.\n\n\nip addr add 10.100.0.10/24 dev eth0\n\n\n\n\nNow open another terminal and do the same for \ninst2\n.\n\n\nlxc-console -n inst2\nip addr add 10.100.0.11/24 dev eth0\n\n\n\n\nNow that both have their IP address set up, you can try having them ping each other. Since we just logged into \ninst2\n, let's ping \ninst1\n from there.\n\n\nping 10.100.0.10\n\n\n\n\nIf everything went well, ping should now be working. If not, review all the steps to make sure you didn't make any mistakes.\n\n\nRemark\n\n\nNow that we've set up this virtual network and tested it, it's a good time to tell you about a difference between traditional networks and OpenVNet's virtual networks.\n\n\nLet's see what happens when we change \ninst2\n's IP address to \n10.100.0.15/24\n\n\nip addr del 10.100.0.11/24 dev eth0\nip addr add 10.100.0.15/24 dev eth0\n\n\n\n\nNow try pinging \ninst1\n again.\n\n\nping 10.100.0.10\n\n\n\n\nWhat do you see? Ping no longer works.\n\n\nOn a tradition network, changing the IP address to anywhere within \n10.100.0.0/24\n would work but OpenVNet is more strict. We have registered \ninst2\n in OpenVNet's database with IP address \n10.100.0.11\n and OpenVNet will not allow it to use anything else.\n\n\nWhat's next?\n\n\nYou've now successfully set up the simplest possible OpenVNet configuration. How about we make this virtual network a little more interesting by adding a \nDHCP service\n?",
            "title": "Single network"
        },
        {
            "location": "/creating-virtual-networks/single-network/#single-network",
            "text": "",
            "title": "Single network"
        },
        {
            "location": "/creating-virtual-networks/single-network/#overview",
            "text": "This is the simplest possible setup after completing the  installation guide . It's a great start for when you're just getting into OpenVNet.  This document expects you to have set up OpenVNet according to the installation guide. We will be referring to the VMs  inst1  and  inst2  as they've been set up in there.  We are going to use them to create the following virtual network topology.   We will just have one simple network:  10.100.0.0/24 .   Inst1 's IP address:  10.100.0.10  Inst2 's IP address:  10.100.0.11",
            "title": "Overview"
        },
        {
            "location": "/creating-virtual-networks/single-network/#setup",
            "text": "",
            "title": "Setup"
        },
        {
            "location": "/creating-virtual-networks/single-network/#create-the-network",
            "text": "vnctl networks add \\\n  --uuid nw-test1 \\\n  --display-name testnet1 \\\n  --ipv4-network 10.100.0.0 \\\n  --ipv4-prefix 24 \\\n  --network-mode virtual",
            "title": "Create the network"
        },
        {
            "location": "/creating-virtual-networks/single-network/#set-up-the-interfaces",
            "text": "Now that we have a virtual network, we need to tell OpenVNet which interfaces are in it and which IP addresses they will get. We need to do this for both  inst1  and  inst2 .  vnctl interfaces add \\\n  --uuid if-inst1 \\\n  --mode vif \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 10:54:ff:00:00:01 \\\n  --network-uuid nw-test1 \\\n  --ipv4-address 10.100.0.10 \\\n  --port-name inst1\n\nvnctl interfaces add \\\n  --uuid if-inst2 \\\n  --mode vif \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 10:54:ff:00:00:02 \\\n  --network-uuid nw-test1 \\\n  --ipv4-address 10.100.0.11 \\\n  --port-name inst2  For more information about the interfaces commands, visit  their section  in the Vnctl documentation.",
            "title": "Set up the interfaces"
        },
        {
            "location": "/creating-virtual-networks/single-network/#test",
            "text": "Log into  inst1  and check its IP address configuration.  lxc-console -n inst1\nip a  If everything went well you will see that it has no IP address assigned to it. That is to be expected. The network we have just set up does not have a DHCP server. Assign the IP address manually.  ip addr add 10.100.0.10/24 dev eth0  Now open another terminal and do the same for  inst2 .  lxc-console -n inst2\nip addr add 10.100.0.11/24 dev eth0  Now that both have their IP address set up, you can try having them ping each other. Since we just logged into  inst2 , let's ping  inst1  from there.  ping 10.100.0.10  If everything went well, ping should now be working. If not, review all the steps to make sure you didn't make any mistakes.",
            "title": "Test"
        },
        {
            "location": "/creating-virtual-networks/single-network/#remark",
            "text": "Now that we've set up this virtual network and tested it, it's a good time to tell you about a difference between traditional networks and OpenVNet's virtual networks.  Let's see what happens when we change  inst2 's IP address to  10.100.0.15/24  ip addr del 10.100.0.11/24 dev eth0\nip addr add 10.100.0.15/24 dev eth0  Now try pinging  inst1  again.  ping 10.100.0.10  What do you see? Ping no longer works.  On a tradition network, changing the IP address to anywhere within  10.100.0.0/24  would work but OpenVNet is more strict. We have registered  inst2  in OpenVNet's database with IP address  10.100.0.11  and OpenVNet will not allow it to use anything else.",
            "title": "Remark"
        },
        {
            "location": "/creating-virtual-networks/single-network/#whats-next",
            "text": "You've now successfully set up the simplest possible OpenVNet configuration. How about we make this virtual network a little more interesting by adding a  DHCP service ?",
            "title": "What's next?"
        },
        {
            "location": "/creating-virtual-networks/single-network-dhcp/",
            "text": "Single network with DHCP server\n\n\nOverview\n\n\nThis document expects you to have set up OpenVNet according to the \ninstallation guide\n and created the simple \nsingle network\n afterwards. We will be continuing from there so complete those guides first.\n\n\nAll we are going to do in this guide is add a DHCP server. This will give us the following virtual network topology.\n\n\n\n\nSetup\n\n\nCreate a simulated interface\n\n\nOpenVNet will simulate DHCP entirely using \nflows\n in Open vSwitch. However, the machines attached to OpenVNet's virtual networks will still expect a DHCP server to exist with a certain IP address. Therefore we need to tell OpenVNet to create a simulated interface that will give off the illusion of a real DHCP server.\n\n\nvnctl interfaces add \\\n  --uuid if-dhcp \\\n  --mode simulated \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 02:00:00:00:01:11 \\\n  --network-uuid nw-test1 \\\n  --ipv4-address 10.100.0.100\n\n\n\n\nCreate the DHCP service\n\n\nNow that we have a simulated interface in place, next we need to tell OpenVNet to simulate a DHCP service on it.\n\n\nvnctl network-services add --uuid ns-dhcp --interface-uuid if-dhcp --type dhcp\n\n\n\n\nTest\n\n\nFirst of all let's have a look at VNA's log file.\n\n\ntail /var/log/openvnet/vna.log\n\n\n\n\nYou should see something like this.\n\n\nD, [2015-12-16T17:17:38.687225 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa interface_manager: installing if-dhcp/3 (mode:simulated)\nD, [2015-12-16T17:17:38.732223 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa active_interface_manager: installing local/3 (interface_id:3 datapath_id:1 label:dp-test1)\nD, [2015-12-16T17:17:38.741769 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa interface/simulated: adding mac address to if-dhcp/3 (02:00:00:00:01:11)\nD, [2015-12-16T17:17:38.763137 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa interface/simulated: adding ipv4 address to if-dhcp/3 (02:00:00:00:01:11/10.100.0.100)\nD, [2015-12-16T17:17:44.662743 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa service_manager: installing ns-dhcp/1 (mode:dhcp)\n\n\n\n\nLooking good so far. VNA seems to have created the simulated interface and added the DHCP service to it.\n\n\nLog into \ninst1\n and have it do a DHCP request.\n\n\nlxc-console -n inst1\nservice network restart\n\n\n\n\nIf everything went well, \ninst1\n should have received a DHCP reply and it now has IP address \n10.100.0.10\n\n\nTaking another look at \n/var/log/openvnet/vna.log\n will show you how the simulated DHCP server has received the request and constructed a reply to it.\n\n\nNow let's do the same on \ninst2\n and see how the DHCP service assigns \n10.100.0.11\n.\n\n\nlxc-console -n inst2\nservice network restart\n\n\n\n\nThere we go. The two VMs can now ping each other again.\n\n\nWhat's next?\n\n\nNow that you've successfully set up a single network and added a DHCP server to it, how about we set up \nmultiple networks\n next?",
            "title": "Single network with DHCP server"
        },
        {
            "location": "/creating-virtual-networks/single-network-dhcp/#single-network-with-dhcp-server",
            "text": "",
            "title": "Single network with DHCP server"
        },
        {
            "location": "/creating-virtual-networks/single-network-dhcp/#overview",
            "text": "This document expects you to have set up OpenVNet according to the  installation guide  and created the simple  single network  afterwards. We will be continuing from there so complete those guides first.  All we are going to do in this guide is add a DHCP server. This will give us the following virtual network topology.",
            "title": "Overview"
        },
        {
            "location": "/creating-virtual-networks/single-network-dhcp/#setup",
            "text": "",
            "title": "Setup"
        },
        {
            "location": "/creating-virtual-networks/single-network-dhcp/#create-a-simulated-interface",
            "text": "OpenVNet will simulate DHCP entirely using  flows  in Open vSwitch. However, the machines attached to OpenVNet's virtual networks will still expect a DHCP server to exist with a certain IP address. Therefore we need to tell OpenVNet to create a simulated interface that will give off the illusion of a real DHCP server.  vnctl interfaces add \\\n  --uuid if-dhcp \\\n  --mode simulated \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 02:00:00:00:01:11 \\\n  --network-uuid nw-test1 \\\n  --ipv4-address 10.100.0.100",
            "title": "Create a simulated interface"
        },
        {
            "location": "/creating-virtual-networks/single-network-dhcp/#create-the-dhcp-service",
            "text": "Now that we have a simulated interface in place, next we need to tell OpenVNet to simulate a DHCP service on it.  vnctl network-services add --uuid ns-dhcp --interface-uuid if-dhcp --type dhcp",
            "title": "Create the DHCP service"
        },
        {
            "location": "/creating-virtual-networks/single-network-dhcp/#test",
            "text": "First of all let's have a look at VNA's log file.  tail /var/log/openvnet/vna.log  You should see something like this.  D, [2015-12-16T17:17:38.687225 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa interface_manager: installing if-dhcp/3 (mode:simulated)\nD, [2015-12-16T17:17:38.732223 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa active_interface_manager: installing local/3 (interface_id:3 datapath_id:1 label:dp-test1)\nD, [2015-12-16T17:17:38.741769 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa interface/simulated: adding mac address to if-dhcp/3 (02:00:00:00:01:11)\nD, [2015-12-16T17:17:38.763137 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa interface/simulated: adding ipv4 address to if-dhcp/3 (02:00:00:00:01:11/10.100.0.100)\nD, [2015-12-16T17:17:44.662743 #19913] DEBUG -- : 0x0000aaaaaaaaaaaa service_manager: installing ns-dhcp/1 (mode:dhcp)  Looking good so far. VNA seems to have created the simulated interface and added the DHCP service to it.  Log into  inst1  and have it do a DHCP request.  lxc-console -n inst1\nservice network restart  If everything went well,  inst1  should have received a DHCP reply and it now has IP address  10.100.0.10  Taking another look at  /var/log/openvnet/vna.log  will show you how the simulated DHCP server has received the request and constructed a reply to it.  Now let's do the same on  inst2  and see how the DHCP service assigns  10.100.0.11 .  lxc-console -n inst2\nservice network restart  There we go. The two VMs can now ping each other again.",
            "title": "Test"
        },
        {
            "location": "/creating-virtual-networks/single-network-dhcp/#whats-next",
            "text": "Now that you've successfully set up a single network and added a DHCP server to it, how about we set up  multiple networks  next?",
            "title": "What's next?"
        },
        {
            "location": "/creating-virtual-networks/two-networks/",
            "text": "Two virtual networks\n\n\nOverview\n\n\nThis document expects you to have set up OpenVNet according to the \ninstallation guide\n, created the simple \nsingle network\n and set up \nits DHCP server\n. We will be continuing from there so complete those guides first.\n\n\nIn this guide we will set up a second virtual network and move \ninst2\n to it. We'll also set up a new DHCP server for that network. That will give us the following topology.\n\n\n\n\nSetup\n\n\nThe first two steps are similar to what we have done before. Create a new network and setup its simulated DHCP service.\n\n\nCreate the new network\n\n\nvnctl networks add \\\n  --uuid nw-test2 \\\n  --display-name testnet2 \\\n  --ipv4-network 192.168.50.0 \\\n  --ipv4-prefix 24 \\\n  --network-mode virtual\n\n\n\n\nSet up its DHCP server\n\n\nvnctl interfaces add \\\n  --uuid if-dhcp2 \\\n  --mode simulated \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 02:00:00:00:01:12 \\\n  --network-uuid nw-test2 \\\n  --ipv4-address 192.168.50.100\n\n\nvnctl network-services add \\\n  --uuid ns-dhcp2 \\\n  --interface-uuid if-dhcp2 \\\n  --type dhcp\n\n\n\n\nMove inst2 to the new network\n\n\nThere are two ways to do this.\n\n\n\n\n\n\nThe quick and dirty way. Remove the interface and re-create it.\n\n\n\n\n\n\nThe clean but slightly harder way. Dig a little deeper into OpenVNet's inner workings make only the required changes.\n\n\n\n\n\n\nChoose one of the two two ways below.\n\n\nThe quick and dirty way.\n\n\nTo keep things simple, we will just remove \ninst2\n from OpenVNet's database and re-create it.\n\n\nA side effect of this method is that we will not be able to use the same UUID. That's because OpenVNet's database uses logical delete. Deleted records aren't actually removed but only marked as deleted. Their unique fields cannot be reused.\n\n\nvnctl interfaces del if-inst2\n\n\n\n\nNow re-create it. Since we can't reuse the UUID \nif-inst2\n, we'll use \nif-newinst2\n.\n\n\nvnctl interfaces add \\\n  --uuid if-newinst2 \\\n  --mode vif \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 10:54:ff:00:00:02 \\\n  --network-uuid nw-test2 \\\n  --ipv4-address 192.168.50.10 \\\n  --port-name inst2\n\n\n\n\nYou're done. Move on to the \ntest section\n.\n\n\nThe clean but slightly harder way\n\n\nWe've now created several network interfaces in OpenVNet using the \nvnctl interfaces add\n command. Actually every time we call that command, OpenVNet creates several fields in the database  to keep track of MAC address, IP address, network assignment etc. The field we need to change here is \nip lease\n.\n\n\nFirst have a look at \ninst2\n's interface.\n\n\nvnctl interfaces show if-inst2\n\n\n\n\nAs you can see, there's quite a bit of information to be had here. The part we're interested in is \nip lease\n and more specifically, the \nip lease UUID\n. Look for it in the output.\n\n\n---\n:id: 2\n:uuid: if-inst2\n:mode: vif\n...\n:mac_leases:\n- :id: 2\n  :uuid: ml-sa4dusgn\n  :interface_id: 2\n  ...\n  :ip_leases:\n  - &1\n    :id: 2\n    :uuid: il-36cl1ou4 # <== This is what we're looking for.\n    :interface_id: 2\n    ...\n\n\n\n\nIn this example it's \nil-36cl1ou4\n but it will be something else on your environment. These UUIDs are randomly generated by OpenVNet when a new resource is created.\n\n\nNow run the following command, replacing the \nil-36cl1ou4\n with the correct UUID for your environment.\n\n\nvnctl ip-leases modify il-36cl1ou4 --network-uuid nw-test2 --ipv4-address 192.168.50.10\n\n\n\n\nThat's it. \ninst2\n has now moved to the new network we created.\n\n\nTest\n\n\nLog into \ninst2\n and have it perform a new DHCP request.\n\n\nlxc-console -n inst2\nservice network restart\n\n\n\n\nIf everything went well, \ninst2\n should now have received IP address \n192.168.50.10\n. Now try pinging \ninst1\n.\n\n\nping 10.100.0.10\n\n\n\n\nIf you did things right, ping should have now told you that \ninst1\n's network is unreachable. That's exactly right. Our LXC guests are now in two different networks and have no route to each other.\n\n\nWhat's next?\n\n\nNow that we have two different networks, let's try \nusing a simulated router\n to connect them together.",
            "title": "Two networks"
        },
        {
            "location": "/creating-virtual-networks/two-networks/#two-virtual-networks",
            "text": "",
            "title": "Two virtual networks"
        },
        {
            "location": "/creating-virtual-networks/two-networks/#overview",
            "text": "This document expects you to have set up OpenVNet according to the  installation guide , created the simple  single network  and set up  its DHCP server . We will be continuing from there so complete those guides first.  In this guide we will set up a second virtual network and move  inst2  to it. We'll also set up a new DHCP server for that network. That will give us the following topology.",
            "title": "Overview"
        },
        {
            "location": "/creating-virtual-networks/two-networks/#setup",
            "text": "The first two steps are similar to what we have done before. Create a new network and setup its simulated DHCP service.",
            "title": "Setup"
        },
        {
            "location": "/creating-virtual-networks/two-networks/#create-the-new-network",
            "text": "vnctl networks add \\\n  --uuid nw-test2 \\\n  --display-name testnet2 \\\n  --ipv4-network 192.168.50.0 \\\n  --ipv4-prefix 24 \\\n  --network-mode virtual",
            "title": "Create the new network"
        },
        {
            "location": "/creating-virtual-networks/two-networks/#set-up-its-dhcp-server",
            "text": "vnctl interfaces add \\\n  --uuid if-dhcp2 \\\n  --mode simulated \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 02:00:00:00:01:12 \\\n  --network-uuid nw-test2 \\\n  --ipv4-address 192.168.50.100\n\n\nvnctl network-services add \\\n  --uuid ns-dhcp2 \\\n  --interface-uuid if-dhcp2 \\\n  --type dhcp",
            "title": "Set up its DHCP server"
        },
        {
            "location": "/creating-virtual-networks/two-networks/#move-inst2-to-the-new-network",
            "text": "There are two ways to do this.    The quick and dirty way. Remove the interface and re-create it.    The clean but slightly harder way. Dig a little deeper into OpenVNet's inner workings make only the required changes.    Choose one of the two two ways below.",
            "title": "Move inst2 to the new network"
        },
        {
            "location": "/creating-virtual-networks/two-networks/#the-quick-and-dirty-way",
            "text": "To keep things simple, we will just remove  inst2  from OpenVNet's database and re-create it.  A side effect of this method is that we will not be able to use the same UUID. That's because OpenVNet's database uses logical delete. Deleted records aren't actually removed but only marked as deleted. Their unique fields cannot be reused.  vnctl interfaces del if-inst2  Now re-create it. Since we can't reuse the UUID  if-inst2 , we'll use  if-newinst2 .  vnctl interfaces add \\\n  --uuid if-newinst2 \\\n  --mode vif \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 10:54:ff:00:00:02 \\\n  --network-uuid nw-test2 \\\n  --ipv4-address 192.168.50.10 \\\n  --port-name inst2  You're done. Move on to the  test section .",
            "title": "The quick and dirty way."
        },
        {
            "location": "/creating-virtual-networks/two-networks/#the-clean-but-slightly-harder-way",
            "text": "We've now created several network interfaces in OpenVNet using the  vnctl interfaces add  command. Actually every time we call that command, OpenVNet creates several fields in the database  to keep track of MAC address, IP address, network assignment etc. The field we need to change here is  ip lease .  First have a look at  inst2 's interface.  vnctl interfaces show if-inst2  As you can see, there's quite a bit of information to be had here. The part we're interested in is  ip lease  and more specifically, the  ip lease UUID . Look for it in the output.  ---\n:id: 2\n:uuid: if-inst2\n:mode: vif\n...\n:mac_leases:\n- :id: 2\n  :uuid: ml-sa4dusgn\n  :interface_id: 2\n  ...\n  :ip_leases:\n  - &1\n    :id: 2\n    :uuid: il-36cl1ou4 # <== This is what we're looking for.\n    :interface_id: 2\n    ...  In this example it's  il-36cl1ou4  but it will be something else on your environment. These UUIDs are randomly generated by OpenVNet when a new resource is created.  Now run the following command, replacing the  il-36cl1ou4  with the correct UUID for your environment.  vnctl ip-leases modify il-36cl1ou4 --network-uuid nw-test2 --ipv4-address 192.168.50.10  That's it.  inst2  has now moved to the new network we created.",
            "title": "The clean but slightly harder way"
        },
        {
            "location": "/creating-virtual-networks/two-networks/#test",
            "text": "Log into  inst2  and have it perform a new DHCP request.  lxc-console -n inst2\nservice network restart  If everything went well,  inst2  should now have received IP address  192.168.50.10 . Now try pinging  inst1 .  ping 10.100.0.10  If you did things right, ping should have now told you that  inst1 's network is unreachable. That's exactly right. Our LXC guests are now in two different networks and have no route to each other.",
            "title": "Test"
        },
        {
            "location": "/creating-virtual-networks/two-networks/#whats-next",
            "text": "Now that we have two different networks, let's try  using a simulated router  to connect them together.",
            "title": "What's next?"
        },
        {
            "location": "/creating-virtual-networks/two-networks-router/",
            "text": "Two virtual networks with router\n\n\nOverview\n\n\nThis document builds on the last guides. If you haven't already, make sure to complete the previous guides first: \nInstallation guide\n, \nSingle Network\n, \nSingle Network with DHCP server\n and \nTwo Networks\n.\n\n\nNow that we have two virtual networks with an interface in each, it makes sense to add a router to them so that both interfaces can reach each other. That's exactly what we'll do in this guide, resulting in the following topology.\n\n\n\n\nSetup\n\n\nCreate the simulated interfaces\n\n\nJust like OpenVNet's DHCP service, routers are simulated entirely in Open vSwitch's \nflows\n. Therefore we are again going to create simulated interfaces. The only difference from DHCP is that this time we are going to set the \nenable_routing\n flag.\n\n\nFirst we'll add a simulated interface to the network \nnw-test1\n (the one \ninst1\n is in) with IP address \n10.100.0.1\n.\n\n\nvnctl interfaces add \\\n  --uuid if-router1 \\\n  --network_uuid nw-test1 \\\n  --mac_address \"02:00:00:00:02:01\" \\\n  --ipv4_address 10.100.0.1 \\\n  --mode simulated \\\n  --enable_routing true\n\n\n\n\nNext we'll add a similar simulated interface to the network \nnw-test2\n (the one \ninst2\n is in) with IP address \n192.168.50.1\n.\n\n\nvnctl interfaces add \\\n  --uuid if-router2 \\\n  --network_uuid nw-test2 \\\n  --mac_address \"02:00:00:00:02:02\" \\\n  --ipv4_address 192.168.50.1 \\\n  --mode simulated \\\n  --enable_routing true\n\n\n\n\nNow we have two new simulated interfaces that are capable of routing but we have not yet told OpenVNet that they should be able to route to each other. For that first we'll create a \nroute_link\n\n\nYou can thing of a \nroute_link\n as a central point that routed traffic passes through.\n\n\nvnctl route_links add --uuid rl-1 --mac-address 02:00:10:00:00:01\n\n\n\n\nNow we are add the actual routes.\n\n\nThese commands bring everything together. They tell OpenVNet to use the \nroute_link\n and the simulated interfaces we just created to set up a router that can connect the networks \nnw-test1\n and \nnw-test2\n.\n\n\nvnctl routes add \\\n  --uuid r-1 \\\n  --interface-uuid if-router1 \\\n  --network-uuid nw-test1 \\\n  --ipv4-network 10.100.0.0 \\\n  --route-link-uuid rl-1\n\nvnctl routes add \\\n  --uuid r-2 \\\n  --interface-uuid if-router2 \\\n  --network-uuid nw-test2 \\\n  --ipv4-network 192.168.50.0 \\\n  --route-link-uuid rl-1\n\n\n\n\nTest\n\n\nRouting is now set up and should be working. We could set up the routing table in our LXC guests manually but we don't need to. All we need to do is have them perform a new DHCP request. OpenVNet will automatically include these routes in its DHCP reply.\n\n\nLog into \ninst1\n and have it do a DHCP request.\n\n\nlxc-console -n inst1\nservice network restart\n\n\n\n\nIf everything went well, it should now have a new entry in its routing table. Try running \nip route show\n. IT should include the following line in its output.\n\n\n192.168.50.0/24 via 10.100.0.1 dev eth0  proto static\n\n\n\n\nNow have \ninst2\n do a new DHCP request as well.\n\n\nlxc-console -n inst2\nservice network restart\n\n\n\n\nNow try to have \ninst2\n ping \ninst1\n again. Now that there is a router connecting both networks, ping should be working. If it's not working, something went wrong. Review the commands and check if you made a mistake anywhere.\n\n\nRemark\n\n\nHave another look at VNA's log file.\n\n\ntail /var/log/openvnet/vna.log\n\n\n\n\nIf you haven't done anything special after the two LXC guests pinged each other, you'll see these lines.\n\n\nI, [2015-12-17T17:28:15.168336 #1538]  INFO -- : 0x0000aaaaaaaaaaaa interface/simulated: simulated arp reply (arp_tpa:192.168.50.1)\nI, [2015-12-17T17:28:15.182135 #1538]  INFO -- : 0x0000aaaaaaaaaaaa interface/simulated: simulated arp reply (arp_tpa:10.100.0.1)\n\n\n\n\nThat's OpenVNet's simulated interfaces in action. To the LXC guests, it looks like they're communicating with regular routers. They discover their MAC Address through ARP and then send IP packets. In reality though, these interfaces don't exist and everything is simulated using OpenFlow.\n\n\nWhat's next\n\n\nYou're done. You have completed all examples contained in this OpenVNet tutorial. There's a couple of things you can from here.\n\n\n\n\n\n\nHave a look at the actual flows in Open vSwitch using the \nvnflows-monitor\n debug tool.\n\n\n\n\n\n\nCheck out the \nintegration test\n for an example of more complicated OpenVNet environments.\n\n\n\n\n\n\nMaybe try adding some more LXC guests and setting up your own virtual network environments.\n\n\n\n\n\n\nHow about trying to create an environment with multiple hosts, each with their own Open vSwitch and VNA. This will require some more setup and is currently not yet covered in this documentation. It will require you to carefully study the examples in the \nintegration test\n.\n\n\n\n\n\n\nThank you for taking the time to check out OpenVNet. Good luck, have fun and be creative.\n\n\nIf you need any further help, don't hesitate to contact us on the \nWakame Users Group\n. We're very busy and might not get back to you immediately but we'll do our very best to help you out.",
            "title": "Two network with router"
        },
        {
            "location": "/creating-virtual-networks/two-networks-router/#two-virtual-networks-with-router",
            "text": "",
            "title": "Two virtual networks with router"
        },
        {
            "location": "/creating-virtual-networks/two-networks-router/#overview",
            "text": "This document builds on the last guides. If you haven't already, make sure to complete the previous guides first:  Installation guide ,  Single Network ,  Single Network with DHCP server  and  Two Networks .  Now that we have two virtual networks with an interface in each, it makes sense to add a router to them so that both interfaces can reach each other. That's exactly what we'll do in this guide, resulting in the following topology.",
            "title": "Overview"
        },
        {
            "location": "/creating-virtual-networks/two-networks-router/#setup",
            "text": "",
            "title": "Setup"
        },
        {
            "location": "/creating-virtual-networks/two-networks-router/#create-the-simulated-interfaces",
            "text": "Just like OpenVNet's DHCP service, routers are simulated entirely in Open vSwitch's  flows . Therefore we are again going to create simulated interfaces. The only difference from DHCP is that this time we are going to set the  enable_routing  flag.  First we'll add a simulated interface to the network  nw-test1  (the one  inst1  is in) with IP address  10.100.0.1 .  vnctl interfaces add \\\n  --uuid if-router1 \\\n  --network_uuid nw-test1 \\\n  --mac_address \"02:00:00:00:02:01\" \\\n  --ipv4_address 10.100.0.1 \\\n  --mode simulated \\\n  --enable_routing true  Next we'll add a similar simulated interface to the network  nw-test2  (the one  inst2  is in) with IP address  192.168.50.1 .  vnctl interfaces add \\\n  --uuid if-router2 \\\n  --network_uuid nw-test2 \\\n  --mac_address \"02:00:00:00:02:02\" \\\n  --ipv4_address 192.168.50.1 \\\n  --mode simulated \\\n  --enable_routing true  Now we have two new simulated interfaces that are capable of routing but we have not yet told OpenVNet that they should be able to route to each other. For that first we'll create a  route_link  You can thing of a  route_link  as a central point that routed traffic passes through.  vnctl route_links add --uuid rl-1 --mac-address 02:00:10:00:00:01  Now we are add the actual routes.  These commands bring everything together. They tell OpenVNet to use the  route_link  and the simulated interfaces we just created to set up a router that can connect the networks  nw-test1  and  nw-test2 .  vnctl routes add \\\n  --uuid r-1 \\\n  --interface-uuid if-router1 \\\n  --network-uuid nw-test1 \\\n  --ipv4-network 10.100.0.0 \\\n  --route-link-uuid rl-1\n\nvnctl routes add \\\n  --uuid r-2 \\\n  --interface-uuid if-router2 \\\n  --network-uuid nw-test2 \\\n  --ipv4-network 192.168.50.0 \\\n  --route-link-uuid rl-1",
            "title": "Create the simulated interfaces"
        },
        {
            "location": "/creating-virtual-networks/two-networks-router/#test",
            "text": "Routing is now set up and should be working. We could set up the routing table in our LXC guests manually but we don't need to. All we need to do is have them perform a new DHCP request. OpenVNet will automatically include these routes in its DHCP reply.  Log into  inst1  and have it do a DHCP request.  lxc-console -n inst1\nservice network restart  If everything went well, it should now have a new entry in its routing table. Try running  ip route show . IT should include the following line in its output.  192.168.50.0/24 via 10.100.0.1 dev eth0  proto static  Now have  inst2  do a new DHCP request as well.  lxc-console -n inst2\nservice network restart  Now try to have  inst2  ping  inst1  again. Now that there is a router connecting both networks, ping should be working. If it's not working, something went wrong. Review the commands and check if you made a mistake anywhere.",
            "title": "Test"
        },
        {
            "location": "/creating-virtual-networks/two-networks-router/#remark",
            "text": "Have another look at VNA's log file.  tail /var/log/openvnet/vna.log  If you haven't done anything special after the two LXC guests pinged each other, you'll see these lines.  I, [2015-12-17T17:28:15.168336 #1538]  INFO -- : 0x0000aaaaaaaaaaaa interface/simulated: simulated arp reply (arp_tpa:192.168.50.1)\nI, [2015-12-17T17:28:15.182135 #1538]  INFO -- : 0x0000aaaaaaaaaaaa interface/simulated: simulated arp reply (arp_tpa:10.100.0.1)  That's OpenVNet's simulated interfaces in action. To the LXC guests, it looks like they're communicating with regular routers. They discover their MAC Address through ARP and then send IP packets. In reality though, these interfaces don't exist and everything is simulated using OpenFlow.",
            "title": "Remark"
        },
        {
            "location": "/creating-virtual-networks/two-networks-router/#whats-next",
            "text": "You're done. You have completed all examples contained in this OpenVNet tutorial. There's a couple of things you can from here.    Have a look at the actual flows in Open vSwitch using the  vnflows-monitor  debug tool.    Check out the  integration test  for an example of more complicated OpenVNet environments.    Maybe try adding some more LXC guests and setting up your own virtual network environments.    How about trying to create an environment with multiple hosts, each with their own Open vSwitch and VNA. This will require some more setup and is currently not yet covered in this documentation. It will require you to carefully study the examples in the  integration test .    Thank you for taking the time to check out OpenVNet. Good luck, have fun and be creative.  If you need any further help, don't hesitate to contact us on the  Wakame Users Group . We're very busy and might not get back to you immediately but we'll do our very best to help you out.",
            "title": "What's next"
        },
        {
            "location": "/advanced-features/filters/",
            "text": "Filters\n\n\nOverview\n\n\nSometimes we want to be able to controll the traffic between our interfaces and block/allow packages when certain conditions are met. In OpenVNet we can achieve this with the filter feature.\n\n\nIn this guide we will use the enviroment created in the \nSingle network with DHCP server\n and set up some filters so that \ninst1\n allows traffic on the arp protocol but blocks all else.\n\n\nSetup\n\n\nBefore getting started we make sure that \ninst1\n and \ninst2\n can communicate both tcp/icmp by doing some simple tests.\n\n\nLog into \ninst2\n and type:\n\n\narping 10.100.0.10\nping 10.100.0.10\nssh 10.100.0.10\n\n\n\n\nThese should all generate responses which indicates packages are being sent/recived.\n\n\nEnable filtering\n\n\nRemark:\n Due to a bug in OpenVNet's internal event queue, it is currently possible for filters not to update correctly. If the following commands don't have the expected result, try restarting VNA.\n\n\nTo use filters we first need to tell OpenVNet that we want traffic to be filterd.\n\n\nvnctl interfaces modify if-inst1 --enable-filtering\n\n\n\n\nCreating the filter item\n\n\nNow we can create the filter item.\n\n\nvnctl filters add \\\n--uuid fil-filter1 \\\n--interface-uuid if-inst1 \\\n--mode static\n\n\n\n\nCreating the rules\n\n\nWe now have a filter that will block all traffic both incoming and outgoing for the interface \nif-inst1\n. Now we will add a rule that opens up the arp protocol. We also set up filters for tcp and icmp protocols to have traffic dropped.\n\n\nvnctl filters static add fil-filter1 \\\n--protocol arp \\\n--ipv4-address 0.0.0.0/0 \\\n--passthrough\n\nvnctl filters static add fil-filter1 \\\n--protocol tcp \\\n--ipv4-address 0.0.0.0/0 \\\n--port-number 0 \\\n--passthrough false\n\nvnctl filters static add fil-filter1 \\\n--protocol icmp \\\n--ipv4-address 0.0.0.0/0 \\\n--passthrough false\n\n\n\n\nipv4-address\n set to 0.0.0.0/ will make the match for every ip address and \nport-number\n set to 0 will match all ports.\nFor more information about filter commands, see \nfilters section\n in the vnctl documentation.\n\n\nTest\n\n\nLog into \ninst2\n and once again type in the commands from before.\n\n\narping 10.100.0.10\nping 10.100.0.10\nssh 10.100.0.10\n\n\n\n\nIf everything went well you will notice that both the ping and ssh command should result in no response while the arping response stays unchanged.\n\n\nBy making use of the filter feature we can create our own blacklist or whitelist according to our needs.",
            "title": "Filters"
        },
        {
            "location": "/advanced-features/filters/#filters",
            "text": "",
            "title": "Filters"
        },
        {
            "location": "/advanced-features/filters/#overview",
            "text": "Sometimes we want to be able to controll the traffic between our interfaces and block/allow packages when certain conditions are met. In OpenVNet we can achieve this with the filter feature.  In this guide we will use the enviroment created in the  Single network with DHCP server  and set up some filters so that  inst1  allows traffic on the arp protocol but blocks all else.",
            "title": "Overview"
        },
        {
            "location": "/advanced-features/filters/#setup",
            "text": "Before getting started we make sure that  inst1  and  inst2  can communicate both tcp/icmp by doing some simple tests.  Log into  inst2  and type:  arping 10.100.0.10\nping 10.100.0.10\nssh 10.100.0.10  These should all generate responses which indicates packages are being sent/recived.",
            "title": "Setup"
        },
        {
            "location": "/advanced-features/filters/#enable-filtering",
            "text": "Remark:  Due to a bug in OpenVNet's internal event queue, it is currently possible for filters not to update correctly. If the following commands don't have the expected result, try restarting VNA.  To use filters we first need to tell OpenVNet that we want traffic to be filterd.  vnctl interfaces modify if-inst1 --enable-filtering",
            "title": "Enable filtering"
        },
        {
            "location": "/advanced-features/filters/#creating-the-filter-item",
            "text": "Now we can create the filter item.  vnctl filters add \\\n--uuid fil-filter1 \\\n--interface-uuid if-inst1 \\\n--mode static",
            "title": "Creating the filter item"
        },
        {
            "location": "/advanced-features/filters/#creating-the-rules",
            "text": "We now have a filter that will block all traffic both incoming and outgoing for the interface  if-inst1 . Now we will add a rule that opens up the arp protocol. We also set up filters for tcp and icmp protocols to have traffic dropped.  vnctl filters static add fil-filter1 \\\n--protocol arp \\\n--ipv4-address 0.0.0.0/0 \\\n--passthrough\n\nvnctl filters static add fil-filter1 \\\n--protocol tcp \\\n--ipv4-address 0.0.0.0/0 \\\n--port-number 0 \\\n--passthrough false\n\nvnctl filters static add fil-filter1 \\\n--protocol icmp \\\n--ipv4-address 0.0.0.0/0 \\\n--passthrough false  ipv4-address  set to 0.0.0.0/ will make the match for every ip address and  port-number  set to 0 will match all ports.\nFor more information about filter commands, see  filters section  in the vnctl documentation.",
            "title": "Creating the rules"
        },
        {
            "location": "/advanced-features/filters/#test",
            "text": "Log into  inst2  and once again type in the commands from before.  arping 10.100.0.10\nping 10.100.0.10\nssh 10.100.0.10  If everything went well you will notice that both the ping and ssh command should result in no response while the arping response stays unchanged.  By making use of the filter feature we can create our own blacklist or whitelist according to our needs.",
            "title": "Test"
        },
        {
            "location": "/debugging/vnflows-monitor/",
            "text": "Vnflows monitor\n\n\nVnflows-monitor is a debug tool that automatically gets installed along with VNA. You can use it to display the flows that are currently present in Open vSwitch.\n\n\nTo run it first make sure that OpenVNet's ruby binary is in your \nPATH\n.\n\n\nPATH=/opt/axsh/openvnet/ruby/bin:${PATH}\n\n\n\n\nNow run it like so:\n\n\ncd /opt/axsh/openvnet/vnet/bin/\n./vnflows-monitor\n\n\n\n\nIf Open vSwitch is running and currently has flows in it, you should see this kind of output.\n\n\n(0): TABLE_CLASSIFIER\n  0-00        0       0 => SWITCH(0x0)               actions=write_metadata:REMOTE(0x0),goto_table:TABLE_TUNNEL_PORTS(3)\n  0-01        0       0 => SWITCH(0x0)              tun_id=0 actions=drop\n  0-02       28       0 => PORT(0x1)                in_port=1 actions=write_metadata:TYPE_INTERFACE|LOCAL(0x1),goto_table:TABLE_INTERFACE_EGRESS_CLASSIFIER(15)\n  0-02       22       0 => PORT(0x2)                in_port=2 actions=write_metadata:TYPE_INTERFACE|LOCAL(0x5),goto_table:TABLE_INTERFACE_EGRESS_CLASSIFIER(15)\n  0-02        0       0 => SWITCH(0x0)              in_port=CONTROLLER actions=write_metadata:LOCAL|NO_CONTROLLER(0x0),goto_table:TABLE_CONTROLLER_PORT(7)\n  0-02        0       0 => PORT(0x7ffffffe)         in_port=LOCAL actions=write_metadata:LOCAL(0x0),goto_table:TABLE_LOCAL_PORT(6)\n(3): TABLE_TUNNEL_PORTS\n  3-00        0       0 => SWITCH(0x0)               actions=drop\n(4): TABLE_TUNNEL_NETWORK_IDS\n  4-00        0       0 => SWITCH(0x0)               actions=drop\n  4-30        0       0 => ROUTE_LINK(0x1)          tun_id=0x10000001,dl_dst=02:00:10:00:00:01 actions=write_metadata:TYPE_ROUTE_LINK(0x1),goto_table:TABLE_ROUTER_CLASSIFIER(33)\n  4-30        0       0 => NETWORK(0x1)             tun_id=0x80000001 actions=write_metadata:TYPE_NETWORK(0x1),goto_table:TABLE_NETWORK_SRC_CLASSIFIER(20)\n  4-30        0       0 => NETWORK(0x2)             tun_id=0x80000002 actions=write_metadata:TYPE_NETWORK(0x2),goto_table:TABLE_NETWORK_SRC_CLASSIFIER(20)\n(6): TABLE_LOCAL_PORT\n  6-00        0       0 => SWITCH(0x0)               actions=drop\n...\n\n\n\n\nAs you can see in this output flows are grouped in what we call \"flow tables\".\n\n\nThe numbers on the left are the flow table index followed the the flow's priority. Packets traversing Open vSwitch start in the flow table with index 0 and will get matched against the flows with the highest priority first.\n\n\nThe next number shows the amount of packets that have been matched against the flow. For most flows in the above example that is 0 but there's two flows that have been matched 28 and 22 times respectively.\n\n\nNext is the flow's cookie. What a cookie is in OpenFlow is beyond the scope of this guide.\n\n\nFinally, on the right we see the data we are matching packets against and the actions we undertake in case a match is found.\n\n\nMonitoring changes in flows as they happen\n\n\nOne of vnflows-monitor's most useful features is the ability to continously monitor flows and report any changes immediately. Try running it with the following arguments.\n\n\ncd /opt/axsh/openvnet/vnet/bin\n./vnflows-monitor -d -c 0\n\n\n\n\nNow it will constantly keep iterating and probably not show any output. While this is going on, try having two VMs in virtual networks ping each other. For example have \ninst1\n from the installation guide ping \ninst2\n.\n\n\nYou should see this kind of output.\n\n\n-------run:4--iteration:43-------\n(0): TABLE_CLASSIFIER\n  0-02       34       0 => PORT(0x1)                in_port=1 actions=write_metadata:TYPE_INTERFACE|LOCAL(0x1),goto_table:TABLE_INTERFACE_EGRESS_CLASSIFIER(15)\n  0-02       28       0 => PORT(0x2)                in_port=2 actions=write_metadata:TYPE_INTERFACE|LOCAL(0x5),goto_table:TABLE_INTERFACE_EGRESS_CLASSIFIER(15)\n(15): TABLE_INTERFACE_EGRESS_CLASSIFIER\n 15-30       11       0 => INTERFACE(0x1)[0x12]     ip,metadata=TYPE_INTERFACE(0x1),dl_src=10:54:ff:00:00:01,nw_src=10.100.0.10 actions=write_metadata:TYPE_NETWORK(0x1),goto_table:TABLE_INTERFACE_EGR\nESS_FILTER(18)\n 15-30        8       0 => INTERFACE(0x5)[0x12]     ip,metadata=TYPE_INTERFACE(0x5),dl_src=10:54:ff:00:00:02,nw_src=192.168.50.10 actions=write_metadata:TYPE_NETWORK(0x2),goto_table:TABLE_INTERFACE_E\nGRESS_FILTER(18)\n(18): TABLE_INTERFACE_EGRESS_FILTER\n 18-00       38       0 => SWITCH(0x0)               actions=goto_table:TABLE_NETWORK_SRC_CLASSIFIER(20)\n(20): TABLE_NETWORK_SRC_CLASSIFIER\n 20-30       25       0 => NETWORK(0x1)             metadata=TYPE_NETWORK(0x1) actions=goto_table:TABLE_ROUTE_INGRESS_INTERFACE(30)\n 20-30       13       0 => NETWORK(0x2)             metadata=TYPE_NETWORK(0x2) actions=goto_table:TABLE_ROUTE_INGRESS_INTERFACE(30)\n(30): TABLE_ROUTE_INGRESS_INTERFACE\n 30-10        8       0 => INTERFACE(0x6)[0x12]     ip,metadata=TYPE_NETWORK(0x1),dl_dst=02:00:00:00:02:01 actions=write_metadata:TYPE_INTERFACE(0x6),goto_table:TABLE_ROUTE_INGRESS_TRANSLATION(31)\n 30-10        8       0 => INTERFACE(0x7)[0x12]     ip,metadata=TYPE_NETWORK(0x2),dl_dst=02:00:00:00:02:02 actions=write_metadata:TYPE_INTERFACE(0x7),goto_table:TABLE_ROUTE_INGRESS_TRANSLATION(31)\n(31): TABLE_ROUTE_INGRESS_TRANSLATION\n 31-90        8       0 => INTERFACE(0x6)           metadata=TYPE_INTERFACE(0x6) actions=goto_table:TABLE_ROUTER_INGRESS_LOOKUP(32)\n 31-90        8       0 => INTERFACE(0x7)           metadata=TYPE_INTERFACE(0x7) actions=goto_table:TABLE_ROUTER_INGRESS_LOOKUP(32)\n(32): TABLE_ROUTER_INGRESS_LOOKUP\n 32-30        8       0 => ROUTE(0x1)               ip,metadata=TYPE_INTERFACE(0x6),nw_src=10.100.0.0/24 actions=write_metadata:TYPE_ROUTE_LINK|REFLECTION(0x1),goto_table:TABLE_ROUTER_CLASSIFIER(33)\n 32-30        8       0 => ROUTE(0x2)               ip,metadata=TYPE_INTERFACE(0x7),nw_src=192.168.50.0/24 actions=write_metadata:TYPE_ROUTE_LINK|REFLECTION(0x1),goto_table:TABLE_ROUTER_CLASSIFIER(33\n)\n33): TABLE_ROUTER_CLASSIFIER\n 33-30       16       0 => ROUTE_LINK(0x1)          metadata=TYPE_ROUTE_LINK(0x1) actions=goto_table:TABLE_ROUTER_EGRESS_LOOKUP(34)\n(34): TABLE_ROUTER_EGRESS_LOOKUP\n 34-30        8       0 => ROUTE(0x1)               ip,metadata=TYPE_ROUTE_LINK(0x1),nw_dst=10.100.0.0/24 actions=write_metadata:0x8000000600000001,goto_table:TABLE_ROUTE_EGRESS_LOOKUP(35)\n 34-30        8       0 => ROUTE(0x2)               ip,metadata=TYPE_ROUTE_LINK(0x1),nw_dst=192.168.50.0/24 actions=write_metadata:0x8000000700000001,goto_table:TABLE_ROUTE_EGRESS_LOOKUP(35)\n(35): TABLE_ROUTE_EGRESS_LOOKUP\n 35-20        8       0 => INTERFACE(0x6)[0x12]     metadata=VALUE_PAIR(0x8000000600000000/0xffffffff00000000)(0x0) actions=write_metadata:0x702000000000006,goto_table:TABLE_ROUTE_EGRESS_TRANSLATION(\n36)\n 35-20        8       0 => INTERFACE(0x7)[0x12]     metadata=VALUE_PAIR(0x8000000700000000/0xffffffff00000000)(0x0) actions=write_metadata:0x702000000000007,goto_table:TABLE_ROUTE_EGRESS_TRANSLATION(\n36)\n(36): TABLE_ROUTE_EGRESS_TRANSLATION\n 36-90        8       0 => INTERFACE(0x6)           metadata=TYPE_INTERFACE(0x6) actions=goto_table:TABLE_ROUTE_EGRESS_INTERFACE(37)\n 36-90        8       0 => INTERFACE(0x7)           metadata=TYPE_INTERFACE(0x7) actions=goto_table:TABLE_ROUTE_EGRESS_INTERFACE(37)\n(37): TABLE_ROUTE_EGRESS_INTERFACE\n 37-20        8       0 => INTERFACE(0x6)[0x12]     metadata=TYPE_INTERFACE(0x6) actions=set_field:02:00:00:00:02:01->eth_src,write_metadata:TYPE_NETWORK(0x1),goto_table:TABLE_ARP_TABLE(40)\n 37-20        8       0 => INTERFACE(0x7)[0x12]     metadata=TYPE_INTERFACE(0x7) actions=set_field:02:00:00:00:02:02->eth_src,write_metadata:TYPE_NETWORK(0x2),goto_table:TABLE_ARP_TABLE(40)\n(40): TABLE_ARP_TABLE\n 40-40        8       0 => INTERFACE(0x1)[0x12]     ip,metadata=TYPE_NETWORK(0x1),nw_dst=10.100.0.10 actions=set_field:10:54:ff:00:00:01->eth_dst,goto_table:TABLE_NETWORK_DST_CLASSIFIER(42)\n 40-40        8       0 => INTERFACE(0x5)[0x12]     ip,metadata=TYPE_NETWORK(0x2),nw_dst=192.168.50.10 actions=set_field:10:54:ff:00:00:02->eth_dst,goto_table:TABLE_NETWORK_DST_CLASSIFIER(42)\n(42): TABLE_NETWORK_DST_CLASSIFIER\n 42-30       25       0 => NETWORK(0x1)             metadata=TYPE_NETWORK(0x1) actions=goto_table:TABLE_NETWORK_DST_MAC_LOOKUP(43)\n 42-30       13       0 => NETWORK(0x2)             metadata=TYPE_NETWORK(0x2) actions=goto_table:TABLE_NETWORK_DST_MAC_LOOKUP(43)\n(43): TABLE_NETWORK_DST_MAC_LOOKUP\n 43-60       12       0 => INTERFACE(0x1)[0x12]     metadata=TYPE_NETWORK(0x1),dl_dst=10:54:ff:00:00:01 actions=write_metadata:TYPE_INTERFACE(0x1),goto_table:TABLE_INTERFACE_INGRESS_FILTER(45)\n 43-60        8       0 => INTERFACE(0x5)[0x12]     metadata=TYPE_NETWORK(0x2),dl_dst=10:54:ff:00:00:02 actions=write_metadata:TYPE_INTERFACE(0x5),goto_table:TABLE_INTERFACE_INGRESS_FILTER(45)\n(45): TABLE_INTERFACE_INGRESS_FILTER\n 45-90       11       0 => INTERFACE(0x1)[0x71]     metadata=TYPE_INTERFACE(0x1) actions=goto_table:TABLE_OUT_PORT_INTERFACE_INGRESS(90)\n 45-90        8       0 => INTERFACE(0x5)[0x71]     metadata=TYPE_INTERFACE(0x5) actions=goto_table:TABLE_OUT_PORT_INTERFACE_INGRESS(90)\n(90): TABLE_OUT_PORT_INTERFACE_INGRESS\n 90-10       12       0 => PORT(0x1)                metadata=TYPE_INTERFACE(0x1) actions=output:1\n 90-10        8       0 => PORT(0x2)                metadata=TYPE_INTERFACE(0x5) actions=output:2\n\n\n\n\n\nAs the ping request and reply traverse Open vSwitch' flows, all the flows that they match will have their match counters incremented. Those and only those will now be outputted by vnflows-monitor. This allows us to immediately see which path our packets followed through Open vSwitch's flows.\n\n\nThis time we used vnflows-monitor to see which flows are matched when a packet comes through but another idea is to change the virtual network topology while it is running. This will show you exactly what flows get added and removed with each step. Have fun.",
            "title": "vnflows-monitor"
        },
        {
            "location": "/debugging/vnflows-monitor/#vnflows-monitor",
            "text": "Vnflows-monitor is a debug tool that automatically gets installed along with VNA. You can use it to display the flows that are currently present in Open vSwitch.  To run it first make sure that OpenVNet's ruby binary is in your  PATH .  PATH=/opt/axsh/openvnet/ruby/bin:${PATH}  Now run it like so:  cd /opt/axsh/openvnet/vnet/bin/\n./vnflows-monitor  If Open vSwitch is running and currently has flows in it, you should see this kind of output.  (0): TABLE_CLASSIFIER\n  0-00        0       0 => SWITCH(0x0)               actions=write_metadata:REMOTE(0x0),goto_table:TABLE_TUNNEL_PORTS(3)\n  0-01        0       0 => SWITCH(0x0)              tun_id=0 actions=drop\n  0-02       28       0 => PORT(0x1)                in_port=1 actions=write_metadata:TYPE_INTERFACE|LOCAL(0x1),goto_table:TABLE_INTERFACE_EGRESS_CLASSIFIER(15)\n  0-02       22       0 => PORT(0x2)                in_port=2 actions=write_metadata:TYPE_INTERFACE|LOCAL(0x5),goto_table:TABLE_INTERFACE_EGRESS_CLASSIFIER(15)\n  0-02        0       0 => SWITCH(0x0)              in_port=CONTROLLER actions=write_metadata:LOCAL|NO_CONTROLLER(0x0),goto_table:TABLE_CONTROLLER_PORT(7)\n  0-02        0       0 => PORT(0x7ffffffe)         in_port=LOCAL actions=write_metadata:LOCAL(0x0),goto_table:TABLE_LOCAL_PORT(6)\n(3): TABLE_TUNNEL_PORTS\n  3-00        0       0 => SWITCH(0x0)               actions=drop\n(4): TABLE_TUNNEL_NETWORK_IDS\n  4-00        0       0 => SWITCH(0x0)               actions=drop\n  4-30        0       0 => ROUTE_LINK(0x1)          tun_id=0x10000001,dl_dst=02:00:10:00:00:01 actions=write_metadata:TYPE_ROUTE_LINK(0x1),goto_table:TABLE_ROUTER_CLASSIFIER(33)\n  4-30        0       0 => NETWORK(0x1)             tun_id=0x80000001 actions=write_metadata:TYPE_NETWORK(0x1),goto_table:TABLE_NETWORK_SRC_CLASSIFIER(20)\n  4-30        0       0 => NETWORK(0x2)             tun_id=0x80000002 actions=write_metadata:TYPE_NETWORK(0x2),goto_table:TABLE_NETWORK_SRC_CLASSIFIER(20)\n(6): TABLE_LOCAL_PORT\n  6-00        0       0 => SWITCH(0x0)               actions=drop\n...  As you can see in this output flows are grouped in what we call \"flow tables\".  The numbers on the left are the flow table index followed the the flow's priority. Packets traversing Open vSwitch start in the flow table with index 0 and will get matched against the flows with the highest priority first.  The next number shows the amount of packets that have been matched against the flow. For most flows in the above example that is 0 but there's two flows that have been matched 28 and 22 times respectively.  Next is the flow's cookie. What a cookie is in OpenFlow is beyond the scope of this guide.  Finally, on the right we see the data we are matching packets against and the actions we undertake in case a match is found.",
            "title": "Vnflows monitor"
        },
        {
            "location": "/debugging/vnflows-monitor/#monitoring-changes-in-flows-as-they-happen",
            "text": "One of vnflows-monitor's most useful features is the ability to continously monitor flows and report any changes immediately. Try running it with the following arguments.  cd /opt/axsh/openvnet/vnet/bin\n./vnflows-monitor -d -c 0  Now it will constantly keep iterating and probably not show any output. While this is going on, try having two VMs in virtual networks ping each other. For example have  inst1  from the installation guide ping  inst2 .  You should see this kind of output.  -------run:4--iteration:43-------\n(0): TABLE_CLASSIFIER\n  0-02       34       0 => PORT(0x1)                in_port=1 actions=write_metadata:TYPE_INTERFACE|LOCAL(0x1),goto_table:TABLE_INTERFACE_EGRESS_CLASSIFIER(15)\n  0-02       28       0 => PORT(0x2)                in_port=2 actions=write_metadata:TYPE_INTERFACE|LOCAL(0x5),goto_table:TABLE_INTERFACE_EGRESS_CLASSIFIER(15)\n(15): TABLE_INTERFACE_EGRESS_CLASSIFIER\n 15-30       11       0 => INTERFACE(0x1)[0x12]     ip,metadata=TYPE_INTERFACE(0x1),dl_src=10:54:ff:00:00:01,nw_src=10.100.0.10 actions=write_metadata:TYPE_NETWORK(0x1),goto_table:TABLE_INTERFACE_EGR\nESS_FILTER(18)\n 15-30        8       0 => INTERFACE(0x5)[0x12]     ip,metadata=TYPE_INTERFACE(0x5),dl_src=10:54:ff:00:00:02,nw_src=192.168.50.10 actions=write_metadata:TYPE_NETWORK(0x2),goto_table:TABLE_INTERFACE_E\nGRESS_FILTER(18)\n(18): TABLE_INTERFACE_EGRESS_FILTER\n 18-00       38       0 => SWITCH(0x0)               actions=goto_table:TABLE_NETWORK_SRC_CLASSIFIER(20)\n(20): TABLE_NETWORK_SRC_CLASSIFIER\n 20-30       25       0 => NETWORK(0x1)             metadata=TYPE_NETWORK(0x1) actions=goto_table:TABLE_ROUTE_INGRESS_INTERFACE(30)\n 20-30       13       0 => NETWORK(0x2)             metadata=TYPE_NETWORK(0x2) actions=goto_table:TABLE_ROUTE_INGRESS_INTERFACE(30)\n(30): TABLE_ROUTE_INGRESS_INTERFACE\n 30-10        8       0 => INTERFACE(0x6)[0x12]     ip,metadata=TYPE_NETWORK(0x1),dl_dst=02:00:00:00:02:01 actions=write_metadata:TYPE_INTERFACE(0x6),goto_table:TABLE_ROUTE_INGRESS_TRANSLATION(31)\n 30-10        8       0 => INTERFACE(0x7)[0x12]     ip,metadata=TYPE_NETWORK(0x2),dl_dst=02:00:00:00:02:02 actions=write_metadata:TYPE_INTERFACE(0x7),goto_table:TABLE_ROUTE_INGRESS_TRANSLATION(31)\n(31): TABLE_ROUTE_INGRESS_TRANSLATION\n 31-90        8       0 => INTERFACE(0x6)           metadata=TYPE_INTERFACE(0x6) actions=goto_table:TABLE_ROUTER_INGRESS_LOOKUP(32)\n 31-90        8       0 => INTERFACE(0x7)           metadata=TYPE_INTERFACE(0x7) actions=goto_table:TABLE_ROUTER_INGRESS_LOOKUP(32)\n(32): TABLE_ROUTER_INGRESS_LOOKUP\n 32-30        8       0 => ROUTE(0x1)               ip,metadata=TYPE_INTERFACE(0x6),nw_src=10.100.0.0/24 actions=write_metadata:TYPE_ROUTE_LINK|REFLECTION(0x1),goto_table:TABLE_ROUTER_CLASSIFIER(33)\n 32-30        8       0 => ROUTE(0x2)               ip,metadata=TYPE_INTERFACE(0x7),nw_src=192.168.50.0/24 actions=write_metadata:TYPE_ROUTE_LINK|REFLECTION(0x1),goto_table:TABLE_ROUTER_CLASSIFIER(33\n)\n33): TABLE_ROUTER_CLASSIFIER\n 33-30       16       0 => ROUTE_LINK(0x1)          metadata=TYPE_ROUTE_LINK(0x1) actions=goto_table:TABLE_ROUTER_EGRESS_LOOKUP(34)\n(34): TABLE_ROUTER_EGRESS_LOOKUP\n 34-30        8       0 => ROUTE(0x1)               ip,metadata=TYPE_ROUTE_LINK(0x1),nw_dst=10.100.0.0/24 actions=write_metadata:0x8000000600000001,goto_table:TABLE_ROUTE_EGRESS_LOOKUP(35)\n 34-30        8       0 => ROUTE(0x2)               ip,metadata=TYPE_ROUTE_LINK(0x1),nw_dst=192.168.50.0/24 actions=write_metadata:0x8000000700000001,goto_table:TABLE_ROUTE_EGRESS_LOOKUP(35)\n(35): TABLE_ROUTE_EGRESS_LOOKUP\n 35-20        8       0 => INTERFACE(0x6)[0x12]     metadata=VALUE_PAIR(0x8000000600000000/0xffffffff00000000)(0x0) actions=write_metadata:0x702000000000006,goto_table:TABLE_ROUTE_EGRESS_TRANSLATION(\n36)\n 35-20        8       0 => INTERFACE(0x7)[0x12]     metadata=VALUE_PAIR(0x8000000700000000/0xffffffff00000000)(0x0) actions=write_metadata:0x702000000000007,goto_table:TABLE_ROUTE_EGRESS_TRANSLATION(\n36)\n(36): TABLE_ROUTE_EGRESS_TRANSLATION\n 36-90        8       0 => INTERFACE(0x6)           metadata=TYPE_INTERFACE(0x6) actions=goto_table:TABLE_ROUTE_EGRESS_INTERFACE(37)\n 36-90        8       0 => INTERFACE(0x7)           metadata=TYPE_INTERFACE(0x7) actions=goto_table:TABLE_ROUTE_EGRESS_INTERFACE(37)\n(37): TABLE_ROUTE_EGRESS_INTERFACE\n 37-20        8       0 => INTERFACE(0x6)[0x12]     metadata=TYPE_INTERFACE(0x6) actions=set_field:02:00:00:00:02:01->eth_src,write_metadata:TYPE_NETWORK(0x1),goto_table:TABLE_ARP_TABLE(40)\n 37-20        8       0 => INTERFACE(0x7)[0x12]     metadata=TYPE_INTERFACE(0x7) actions=set_field:02:00:00:00:02:02->eth_src,write_metadata:TYPE_NETWORK(0x2),goto_table:TABLE_ARP_TABLE(40)\n(40): TABLE_ARP_TABLE\n 40-40        8       0 => INTERFACE(0x1)[0x12]     ip,metadata=TYPE_NETWORK(0x1),nw_dst=10.100.0.10 actions=set_field:10:54:ff:00:00:01->eth_dst,goto_table:TABLE_NETWORK_DST_CLASSIFIER(42)\n 40-40        8       0 => INTERFACE(0x5)[0x12]     ip,metadata=TYPE_NETWORK(0x2),nw_dst=192.168.50.10 actions=set_field:10:54:ff:00:00:02->eth_dst,goto_table:TABLE_NETWORK_DST_CLASSIFIER(42)\n(42): TABLE_NETWORK_DST_CLASSIFIER\n 42-30       25       0 => NETWORK(0x1)             metadata=TYPE_NETWORK(0x1) actions=goto_table:TABLE_NETWORK_DST_MAC_LOOKUP(43)\n 42-30       13       0 => NETWORK(0x2)             metadata=TYPE_NETWORK(0x2) actions=goto_table:TABLE_NETWORK_DST_MAC_LOOKUP(43)\n(43): TABLE_NETWORK_DST_MAC_LOOKUP\n 43-60       12       0 => INTERFACE(0x1)[0x12]     metadata=TYPE_NETWORK(0x1),dl_dst=10:54:ff:00:00:01 actions=write_metadata:TYPE_INTERFACE(0x1),goto_table:TABLE_INTERFACE_INGRESS_FILTER(45)\n 43-60        8       0 => INTERFACE(0x5)[0x12]     metadata=TYPE_NETWORK(0x2),dl_dst=10:54:ff:00:00:02 actions=write_metadata:TYPE_INTERFACE(0x5),goto_table:TABLE_INTERFACE_INGRESS_FILTER(45)\n(45): TABLE_INTERFACE_INGRESS_FILTER\n 45-90       11       0 => INTERFACE(0x1)[0x71]     metadata=TYPE_INTERFACE(0x1) actions=goto_table:TABLE_OUT_PORT_INTERFACE_INGRESS(90)\n 45-90        8       0 => INTERFACE(0x5)[0x71]     metadata=TYPE_INTERFACE(0x5) actions=goto_table:TABLE_OUT_PORT_INTERFACE_INGRESS(90)\n(90): TABLE_OUT_PORT_INTERFACE_INGRESS\n 90-10       12       0 => PORT(0x1)                metadata=TYPE_INTERFACE(0x1) actions=output:1\n 90-10        8       0 => PORT(0x2)                metadata=TYPE_INTERFACE(0x5) actions=output:2  As the ping request and reply traverse Open vSwitch' flows, all the flows that they match will have their match counters incremented. Those and only those will now be outputted by vnflows-monitor. This allows us to immediately see which path our packets followed through Open vSwitch's flows.  This time we used vnflows-monitor to see which flows are matched when a packet comes through but another idea is to change the virtual network topology while it is running. This will show you exactly what flows get added and removed with each step. Have fun.",
            "title": "Monitoring changes in flows as they happen"
        },
        {
            "location": "/debugging/integration-test/",
            "text": "Integration test\n\n\nWe have an integration test environment set up for OpenVNet on which we \nalways\n test code changes before merging them. The environment looks like this.\n\n\n\n\nAs you can see this is a pretty complicated environment. It consists of multiple KVM virtual machines, several of which have Open vSwitch and VNA running. Then there's others that act as \ntraditional networks\n, allowing us to test \nVNet Edge\n among other things.\n\n\nThis environment is portable and you can try setting it up for yourself but be aware that you will require a Linux machine capable of nested KVM. The setup scripts along with a README file can be found on \nour wakameci github account\n.\n\n\nEven if you don't set up the integration test for yourself, it can provide examples of how different virtual network topologies are set up.\n\n\nWhile the test environment setup code can be found on the wakameci account, the integration code itself is located \nin the OpenVNet repository\n itself.\n\n\nThe dataset directory in there contains yaml files that translate directly to \nvnctl\n commands. The file \ndataset/base.yml\n will show you you how to configure a multi-host OpenVNet setup. while all the other files in that directory create various virtual network topologies.\n\n\nFiguring out the integration test environment can be a daunting task at first but it's the best resource after completing the guides on this site. Good luck.",
            "title": "Integration test"
        },
        {
            "location": "/debugging/integration-test/#integration-test",
            "text": "We have an integration test environment set up for OpenVNet on which we  always  test code changes before merging them. The environment looks like this.   As you can see this is a pretty complicated environment. It consists of multiple KVM virtual machines, several of which have Open vSwitch and VNA running. Then there's others that act as  traditional networks , allowing us to test  VNet Edge  among other things.  This environment is portable and you can try setting it up for yourself but be aware that you will require a Linux machine capable of nested KVM. The setup scripts along with a README file can be found on  our wakameci github account .  Even if you don't set up the integration test for yourself, it can provide examples of how different virtual network topologies are set up.  While the test environment setup code can be found on the wakameci account, the integration code itself is located  in the OpenVNet repository  itself.  The dataset directory in there contains yaml files that translate directly to  vnctl  commands. The file  dataset/base.yml  will show you you how to configure a multi-host OpenVNet setup. while all the other files in that directory create various virtual network topologies.  Figuring out the integration test environment can be a daunting task at first but it's the best resource after completing the guides on this site. Good luck.",
            "title": "Integration test"
        },
        {
            "location": "/debugging/troubleshooting/",
            "text": "Troubleshooting\n\n\nSo something went wrong. What should you do?\n\n\nMake sure all required services are running\n\n\nservice mysqld status\nservice redis status\n\ninitctl status vnet-vnmgr\ninitctl status vnet-webapi\ninitctl status vnet-vna\n\n\n\n\nIf any of these services are not running, start them. Make sure that they are still running after starting them. It is possible for a service to start successfully but go down again immediately afterwards.\n\n\nIf any of these services aren't starting correctly, look for clues in the log files in \n/var/log/openvnet\n.\n\n\nMake sure the database exists and is populated.\n\n\nmysql -u root\n\nuse vnet;\nshow tables;\n\n\n\n\nIf the database or tables don't exist, set it up as specified in the \ninstallation guide\n.\n\n\nDouble check all vnctl commands\n\n\nMistakes are easily made. Review your vnctl commands carefully and make sure you didn't make any typos.\n\n\nCheck if VNA is connected to Open vSwitch\n\n\nRun \novs-vsctl show\n. The output should look similar to this.\n\n\n54b868bc-04fa-44d7-831a-00cb8eff7ee2\n    Bridge \"br0\"\n        Controller \"tcp:127.0.0.1:6633\"\n            is_connected: true\n        fail_mode: secure\n        Port \"inst2\"\n            Interface \"inst2\"\n        Port \"br0\"\n            Interface \"br0\"\n                type: internal\n        Port \"inst1\"\n            Interface \"inst1\"\n    ovs_version: \"2.3.1\"\n\n\n\n\nIf you are missing the \nis_connected: true\n line then VNA isn't connected to Open vSwitch. In that case, run the following command.\n\n\nvnctl datapaths show\n\n\n\n\nIts output should contain something similar to the following.\n\n\n- :id: 1\n  :uuid: dp-test1\n  :display_name: test1\n  :dpid: '0x0000aaaaaaaaaaaa'\n  :node_id: vna\n  :is_connected: false\n  :created_at: 2015-12-18 04:13:28.000000000 Z\n  :updated_at: 2015-12-18 04:13:28.000000000 Z\n  :deleted_at:\n  :is_deleted: 0\n\n\n\n\nCheck if the \nnode_id\n in there is the same as the one defined in \n/etc/openvnet/vna.conf\n.\n\n\nAlso check the \ndpid\n. It should be the same as outputted the following command.\n\n\novs-vsctl list bridge | grep datapath_id\n\n\n\n\nIf the above command outputted more than one line, you have more than one bridge set up with Open vSwitch. Make sure the correct one is registered with OpenVnet.\n\n\nIf either of these need to be changed you can do so with the following command.\n\n\nvnctl datapaths modify dp-test1 --dpid 0xdeadbeefdeadbeef --node-id foobar\n\n\n\n\nCheck if Open vSwitch's ports are connected\n\n\nRun the \novs-vsctl show\n command again. Like in the section above, the output should look similar to this.\n\n\n54b868bc-04fa-44d7-831a-00cb8eff7ee2\n    Bridge \"br0\"\n        Controller \"tcp:127.0.0.1:6633\"\n            is_connected: true\n        fail_mode: secure\n        Port \"inst2\"\n            Interface \"inst2\"\n        Port \"br0\"\n            Interface \"br0\"\n                type: internal\n        Port \"inst1\"\n            Interface \"inst1\"\n    ovs_version: \"2.3.1\"\n\n\n\n\nIf you followed the installation guide, the ports \ninst1\n and \ninst2\n should be there. If not, add them as specified \nin the guide\n.\n\n\nIf Open vSwitch was shut down incorrectly in the past, it's possible for ports to show up even when they're not really connected. In that case try removing and re-adding them.\n\n\novs-vsctl del-port br0 inst1\novs-vsctl del-port br0 inst2\n\novs-vsctl add-port br0 inst1\novs-vsctl add-port br0 inst2\n\n\n\n\nUse tcpdump\n\n\nTcpdump is a very useful tool for debugging networks. You can install it on Centos with the following command.\n\n\nyum install tcpdump\n\n\n\n\nThere are many tutorials out there on how to use it. Have your network setup do some actions (like ping) that you think should work and use tcpdump to figure out exactly where things go wrong.\n\n\nUse vnflows-monitor\n\n\nSo you've used tcpdump and noticed that it's inside Open vSwitch that things are going wrong? In that case OpenVNet is probably configured incorrectly. You can use the vnflows-monitor debug tool to see exactly which flows get matched and figure where things go wrong. Read more about vnflows-monitor in \nits own guide\n.\n\n\nContact us\n\n\nSo you've tried everything and just can't figure it out? Contact us on the \nWakame Users Group\n. We are very busy and might not be able to reply right away but we will do our very best to help you.",
            "title": "Troubleshooting"
        },
        {
            "location": "/debugging/troubleshooting/#troubleshooting",
            "text": "So something went wrong. What should you do?",
            "title": "Troubleshooting"
        },
        {
            "location": "/debugging/troubleshooting/#make-sure-all-required-services-are-running",
            "text": "service mysqld status\nservice redis status\n\ninitctl status vnet-vnmgr\ninitctl status vnet-webapi\ninitctl status vnet-vna  If any of these services are not running, start them. Make sure that they are still running after starting them. It is possible for a service to start successfully but go down again immediately afterwards.  If any of these services aren't starting correctly, look for clues in the log files in  /var/log/openvnet .",
            "title": "Make sure all required services are running"
        },
        {
            "location": "/debugging/troubleshooting/#make-sure-the-database-exists-and-is-populated",
            "text": "mysql -u root\n\nuse vnet;\nshow tables;  If the database or tables don't exist, set it up as specified in the  installation guide .",
            "title": "Make sure the database exists and is populated."
        },
        {
            "location": "/debugging/troubleshooting/#double-check-all-vnctl-commands",
            "text": "Mistakes are easily made. Review your vnctl commands carefully and make sure you didn't make any typos.",
            "title": "Double check all vnctl commands"
        },
        {
            "location": "/debugging/troubleshooting/#check-if-vna-is-connected-to-open-vswitch",
            "text": "Run  ovs-vsctl show . The output should look similar to this.  54b868bc-04fa-44d7-831a-00cb8eff7ee2\n    Bridge \"br0\"\n        Controller \"tcp:127.0.0.1:6633\"\n            is_connected: true\n        fail_mode: secure\n        Port \"inst2\"\n            Interface \"inst2\"\n        Port \"br0\"\n            Interface \"br0\"\n                type: internal\n        Port \"inst1\"\n            Interface \"inst1\"\n    ovs_version: \"2.3.1\"  If you are missing the  is_connected: true  line then VNA isn't connected to Open vSwitch. In that case, run the following command.  vnctl datapaths show  Its output should contain something similar to the following.  - :id: 1\n  :uuid: dp-test1\n  :display_name: test1\n  :dpid: '0x0000aaaaaaaaaaaa'\n  :node_id: vna\n  :is_connected: false\n  :created_at: 2015-12-18 04:13:28.000000000 Z\n  :updated_at: 2015-12-18 04:13:28.000000000 Z\n  :deleted_at:\n  :is_deleted: 0  Check if the  node_id  in there is the same as the one defined in  /etc/openvnet/vna.conf .  Also check the  dpid . It should be the same as outputted the following command.  ovs-vsctl list bridge | grep datapath_id  If the above command outputted more than one line, you have more than one bridge set up with Open vSwitch. Make sure the correct one is registered with OpenVnet.  If either of these need to be changed you can do so with the following command.  vnctl datapaths modify dp-test1 --dpid 0xdeadbeefdeadbeef --node-id foobar",
            "title": "Check if VNA is connected to Open vSwitch"
        },
        {
            "location": "/debugging/troubleshooting/#check-if-open-vswitchs-ports-are-connected",
            "text": "Run the  ovs-vsctl show  command again. Like in the section above, the output should look similar to this.  54b868bc-04fa-44d7-831a-00cb8eff7ee2\n    Bridge \"br0\"\n        Controller \"tcp:127.0.0.1:6633\"\n            is_connected: true\n        fail_mode: secure\n        Port \"inst2\"\n            Interface \"inst2\"\n        Port \"br0\"\n            Interface \"br0\"\n                type: internal\n        Port \"inst1\"\n            Interface \"inst1\"\n    ovs_version: \"2.3.1\"  If you followed the installation guide, the ports  inst1  and  inst2  should be there. If not, add them as specified  in the guide .  If Open vSwitch was shut down incorrectly in the past, it's possible for ports to show up even when they're not really connected. In that case try removing and re-adding them.  ovs-vsctl del-port br0 inst1\novs-vsctl del-port br0 inst2\n\novs-vsctl add-port br0 inst1\novs-vsctl add-port br0 inst2",
            "title": "Check if Open vSwitch's ports are connected"
        },
        {
            "location": "/debugging/troubleshooting/#use-tcpdump",
            "text": "Tcpdump is a very useful tool for debugging networks. You can install it on Centos with the following command.  yum install tcpdump  There are many tutorials out there on how to use it. Have your network setup do some actions (like ping) that you think should work and use tcpdump to figure out exactly where things go wrong.",
            "title": "Use tcpdump"
        },
        {
            "location": "/debugging/troubleshooting/#use-vnflows-monitor",
            "text": "So you've used tcpdump and noticed that it's inside Open vSwitch that things are going wrong? In that case OpenVNet is probably configured incorrectly. You can use the vnflows-monitor debug tool to see exactly which flows get matched and figure where things go wrong. Read more about vnflows-monitor in  its own guide .",
            "title": "Use vnflows-monitor"
        },
        {
            "location": "/debugging/troubleshooting/#contact-us",
            "text": "So you've tried everything and just can't figure it out? Contact us on the  Wakame Users Group . We are very busy and might not be able to reply right away but we will do our very best to help you.",
            "title": "Contact us"
        },
        {
            "location": "/configuration-files/common/",
            "text": "common.conf\n\n\nThis file contains common configuration that is used by \nvnmgr\n, \nwebapi\n and \nvna\n.\n\n\nYou'll find it at \n/etc/openvnet/vnmgr.conf\n.\n\n\nIt is divided into the following sections.\n\n\nRegistry\n\n\nThis is the key-value storage that the \nDCell framework\n requires. OpenVNet's services use DCell to communicate with each other.\n\n\nregistry {\n  adapter \"redis\"\n  host \"127.0.0.1\"\n  port 6379\n}\n\n\n\n\n\n\nadapter\n\n\n\n\nThe name of key-value store. Defalut value is 'redis'.\n\n\n\n\nhost\n\n\n\n\nIP address of the key-value store.\n\n\n\n\nport\n\n\n\n\nTCP port that the key-value process is listening on.\n\n\nDB\n\n\nThis holds all the information OpenVNet needs to connect to its \nMySQL\n database.\n\n\ndb {\n  adapter \"mysql2\"\n  host \"localhost\"\n  database \"vnet\"\n  port 3306\n  user \"root\"\n  password \"\"\n}\n\n\n\n\n\n\nadapter\n\n\n\n\nThe adapter name for the database. OpenVNet only support \nmysql\n at this time.\n\n\n\n\nhost\n\n\n\n\nIP address of the db server.\n\n\n\n\ndatabase\n\n\n\n\nThe name of the database.\n\n\n\n\nport\n\n\n\n\nListen port of the db server.\n\n\n\n\nuser\n\n\n\n\nUser name of the db server.\n\n\n\n\npassword\n\n\n\n\nPassword of the db server.\n\n\nMisc\n\n\ndatapath_mac_group \"mrg-dpg\"\n\n\n\n\n\n\ndatapath_mac_group\n\n\n\n\nContains the UUID of the mac range group used for \ndatapath_network\n and \ndatapath_route_link\n mac addresses.",
            "title": "common.conf"
        },
        {
            "location": "/configuration-files/common/#commonconf",
            "text": "This file contains common configuration that is used by  vnmgr ,  webapi  and  vna .  You'll find it at  /etc/openvnet/vnmgr.conf .  It is divided into the following sections.",
            "title": "common.conf"
        },
        {
            "location": "/configuration-files/common/#registry",
            "text": "This is the key-value storage that the  DCell framework  requires. OpenVNet's services use DCell to communicate with each other.  registry {\n  adapter \"redis\"\n  host \"127.0.0.1\"\n  port 6379\n}   adapter   The name of key-value store. Defalut value is 'redis'.   host   IP address of the key-value store.   port   TCP port that the key-value process is listening on.",
            "title": "Registry"
        },
        {
            "location": "/configuration-files/common/#db",
            "text": "This holds all the information OpenVNet needs to connect to its  MySQL  database.  db {\n  adapter \"mysql2\"\n  host \"localhost\"\n  database \"vnet\"\n  port 3306\n  user \"root\"\n  password \"\"\n}   adapter   The adapter name for the database. OpenVNet only support  mysql  at this time.   host   IP address of the db server.   database   The name of the database.   port   Listen port of the db server.   user   User name of the db server.   password   Password of the db server.",
            "title": "DB"
        },
        {
            "location": "/configuration-files/common/#misc",
            "text": "datapath_mac_group \"mrg-dpg\"   datapath_mac_group   Contains the UUID of the mac range group used for  datapath_network  and  datapath_route_link  mac addresses.",
            "title": "Misc"
        },
        {
            "location": "/configuration-files/vnmgr/",
            "text": "vnmgr.conf\n\n\nThis file contains the configuration used by \nvnmgr\n.\n\n\nYou'll find it at \n/etc/openvnet/vnmgr.conf\n.\n\n\nnode {\n  id \"vnmgr\"\n  addr {\n    protocol \"tcp\"\n    host \"127.0.0.1\"\n    public \"\"\n    port 9102\n  }\n  plugins [:vdc_vnet_plugin]\n}\n\n\n\n\n\n\nid\n\n\n\n\nThe ID of the OpenVNet's process. It should be unique among the entire world of the OpenVNet.\n\n\n\n\nprotocol\n\n\n\n\nThis parameter can be used to specify the 0MQ address. Default value is 'tcp'.\n\n\n\n\nhost\n\n\n\n\nPrivate IP address that can be used to specify the 0MQ address.\n\n\n\n\npublic\n\n\n\n\nPublic/Global IP address that is linked to the private IP address specified by the 'host' parameter. A 0MQ socket will be created with the public/global IP address if this paramter is specified. Otherwise 'host' parameter will be used to create a 0MQ socket.\n\n\n\n\nport\n\n\n\n\nListen port of the process.\n\n\n\n\nplugins\n\n\n\n\nCurrently the only plugin available is for integration with \nWakame-vdc\n. Even when you're not integration with Wakame-vdc, you can leave it in place. It will not cause any problems.",
            "title": "vnmgr.conf"
        },
        {
            "location": "/configuration-files/vnmgr/#vnmgrconf",
            "text": "This file contains the configuration used by  vnmgr .  You'll find it at  /etc/openvnet/vnmgr.conf .  node {\n  id \"vnmgr\"\n  addr {\n    protocol \"tcp\"\n    host \"127.0.0.1\"\n    public \"\"\n    port 9102\n  }\n  plugins [:vdc_vnet_plugin]\n}   id   The ID of the OpenVNet's process. It should be unique among the entire world of the OpenVNet.   protocol   This parameter can be used to specify the 0MQ address. Default value is 'tcp'.   host   Private IP address that can be used to specify the 0MQ address.   public   Public/Global IP address that is linked to the private IP address specified by the 'host' parameter. A 0MQ socket will be created with the public/global IP address if this paramter is specified. Otherwise 'host' parameter will be used to create a 0MQ socket.   port   Listen port of the process.   plugins   Currently the only plugin available is for integration with  Wakame-vdc . Even when you're not integration with Wakame-vdc, you can leave it in place. It will not cause any problems.",
            "title": "vnmgr.conf"
        },
        {
            "location": "/configuration-files/webapi/",
            "text": "webapi.conf\n\n\nThis file contains the configuration used by \nwebapi\n.\n\n\nYou'll find it at \n/etc/openvnet/webapi.conf\n.\n\n\nnode {\n  id \"vnmgr\"\n  addr {\n    protocol \"tcp\"\n    host \"127.0.0.1\"\n    public \"\"\n    port 9102\n  }\n  plugins [:vdc_vnet_plugin]\n}\n\n\n\n\n\n\nid\n\n\n\n\nThe ID of the OpenVNet's process. It should be unique among the entire world of the OpenVNet.\n\n\n\n\nprotocol\n\n\n\n\nThis parameter can be used to specify the 0MQ address. Default value is 'tcp'.\n\n\n\n\nhost\n\n\n\n\nPrivate IP address that can be used to specify the 0MQ address.\n\n\n\n\npublic\n\n\n\n\nPublic/Global IP address that is linked to the private IP address specified by the 'host' parameter. A 0MQ socket will be created with the public/global IP address if this paramter is specified. Otherwise 'host' parameter will be used to create a 0MQ socket.\n\n\n\n\nport\n\n\n\n\nListen port of the process.\n\n\n\n\nplugins\n\n\n\n\ncurrently the only plugin available is for integration with \nWakame-vdc\n. Even when you're not integration with Wakame-vdc, you can leave it in place. It will not cause any problems.",
            "title": "webapi.conf"
        },
        {
            "location": "/configuration-files/webapi/#webapiconf",
            "text": "This file contains the configuration used by  webapi .  You'll find it at  /etc/openvnet/webapi.conf .  node {\n  id \"vnmgr\"\n  addr {\n    protocol \"tcp\"\n    host \"127.0.0.1\"\n    public \"\"\n    port 9102\n  }\n  plugins [:vdc_vnet_plugin]\n}   id   The ID of the OpenVNet's process. It should be unique among the entire world of the OpenVNet.   protocol   This parameter can be used to specify the 0MQ address. Default value is 'tcp'.   host   Private IP address that can be used to specify the 0MQ address.   public   Public/Global IP address that is linked to the private IP address specified by the 'host' parameter. A 0MQ socket will be created with the public/global IP address if this paramter is specified. Otherwise 'host' parameter will be used to create a 0MQ socket.   port   Listen port of the process.   plugins   currently the only plugin available is for integration with  Wakame-vdc . Even when you're not integration with Wakame-vdc, you can leave it in place. It will not cause any problems.",
            "title": "webapi.conf"
        },
        {
            "location": "/configuration-files/vna/",
            "text": "vna.conf\n\n\nThis file contains the configuration used by \nvna\n.\n\n\nYou'll find it at \n/etc/openvnet/vna.conf\n.\n\n\nIt contains two sections.\n\n\nNode\n\n\nThis is similar to the node sections found in other config files. It's all the information OpenVNet needs to enable this vna to communicate with all other OpenVNet processes.\n\n\nnode {\n  id \"vna\"\n  addr {\n    protocol \"tcp\"\n    host \"127.0.0.1\"\n    public \"\"\n    port 9103\n  }\n}\n\n\n\n\n\n\nid\n\n\n\n\nThe ID of the OpenVNet's process. It should be unique among the entire world of the OpenVNet.\n\n\n\n\nprotocol\n\n\n\n\nThis parameter can be used to specify the 0MQ address. Default value is 'tcp'.\n\n\n\n\nhost\n\n\n\n\nPrivate IP address that can be used to specify the 0MQ address.\n\n\n\n\npublic\n\n\n\n\nPublic/Global IP address that is linked to the private IP address specified by the 'host' parameter. A 0MQ socket will be created with the public/global IP address if this paramter is specified. Otherwise 'host' parameter will be used to create a 0MQ socket.\n\n\n\n\nport\n\n\n\n\nListen port of the process.\n\n\nNetwork\n\n\nThis lets OpenVNet know what physical network this VNA is in. Whe installing OpenVNet on a single machine like we do in the \ninstallation guide\n, this section can be left empty.\n\n\nnetwork {\n  uuid \"\"\n  gateway {\n    address \"\"\n  }\n}\n\n\n\n\n\n\nuuid\n\n\n\n\nThe uuid of the public/physical network in which the vna participates.\n\n\n\n\naddress\n\n\n\n\nThe gateway address of the network specified by the 'uuid'.",
            "title": "vna.conf"
        },
        {
            "location": "/configuration-files/vna/#vnaconf",
            "text": "This file contains the configuration used by  vna .  You'll find it at  /etc/openvnet/vna.conf .  It contains two sections.",
            "title": "vna.conf"
        },
        {
            "location": "/configuration-files/vna/#node",
            "text": "This is similar to the node sections found in other config files. It's all the information OpenVNet needs to enable this vna to communicate with all other OpenVNet processes.  node {\n  id \"vna\"\n  addr {\n    protocol \"tcp\"\n    host \"127.0.0.1\"\n    public \"\"\n    port 9103\n  }\n}   id   The ID of the OpenVNet's process. It should be unique among the entire world of the OpenVNet.   protocol   This parameter can be used to specify the 0MQ address. Default value is 'tcp'.   host   Private IP address that can be used to specify the 0MQ address.   public   Public/Global IP address that is linked to the private IP address specified by the 'host' parameter. A 0MQ socket will be created with the public/global IP address if this paramter is specified. Otherwise 'host' parameter will be used to create a 0MQ socket.   port   Listen port of the process.",
            "title": "Node"
        },
        {
            "location": "/configuration-files/vna/#network",
            "text": "This lets OpenVNet know what physical network this VNA is in. Whe installing OpenVNet on a single machine like we do in the  installation guide , this section can be left empty.  network {\n  uuid \"\"\n  gateway {\n    address \"\"\n  }\n}   uuid   The uuid of the public/physical network in which the vna participates.   address   The gateway address of the network specified by the 'uuid'.",
            "title": "Network"
        },
        {
            "location": "/configuration-files/vnctl/",
            "text": "vnctl.conf\n\n\nThis file contains configuration that is required by \nvnctl\n. This one looks a little different from all other OpenVNet configuration files because \nvnctl\n is not an OpenVNet process like the others. It's just a simple client that makes HTTP requests to OpenVNet's Web API. This will often be installed on client machines that are actually not running OpenVNet themselves.\n\n\nYou'll find it at \n/etc/openvnet/vnctl.conf\n.\n\n\nwebapi_protocol 'http'\nwebapi_uri  '127.0.0.1'\nwebapi_port '9090'\nwebapi_version '1.0'\noutput_format 'yml'\n\n\n\n\n\n\nwebapi_protocol\n\n\n\n\nThe protocol used by the Web API. Currently only 'http' is supported.\n\n\n\n\nwebapi_uri\n\n\n\n\nThe uri where the Web API is running.\n\n\n\n\nwebapi_port\n\n\n\n\nThe TCP port that the Web API is listening on.\n\n\n\n\nwebapi_version\n\n\n\n\nThe Web API's version. Currently '1.0' is the only version that exists.\n\n\n\n\noutput_format\n\n\n\n\nThe format in which you want the Web API to respond. Can be either \nyml\n or \njson\n.",
            "title": "vnctl.conf"
        },
        {
            "location": "/configuration-files/vnctl/#vnctlconf",
            "text": "This file contains configuration that is required by  vnctl . This one looks a little different from all other OpenVNet configuration files because  vnctl  is not an OpenVNet process like the others. It's just a simple client that makes HTTP requests to OpenVNet's Web API. This will often be installed on client machines that are actually not running OpenVNet themselves.  You'll find it at  /etc/openvnet/vnctl.conf .  webapi_protocol 'http'\nwebapi_uri  '127.0.0.1'\nwebapi_port '9090'\nwebapi_version '1.0'\noutput_format 'yml'   webapi_protocol   The protocol used by the Web API. Currently only 'http' is supported.   webapi_uri   The uri where the Web API is running.   webapi_port   The TCP port that the Web API is listening on.   webapi_version   The Web API's version. Currently '1.0' is the only version that exists.   output_format   The format in which you want the Web API to respond. Can be either  yml  or  json .",
            "title": "vnctl.conf"
        },
        {
            "location": "/vnctl/datapaths/",
            "text": "datapaths add\n\n\nThis page explains the arguments used by the \nvnctl datapaths add\n command in the \ninstallation guide\n).\n\n\nvnctl datapaths add \\\n --uuid dp-test1 \\\n --display-name test1 \\\n --dpid 0x0000aaaaaaaaaaaa \\\n --node-id vna\n\n\n\n\n\n\nuuid\n\n\n\n\nA unique ID that will be used to refer to this datapath.\n\n\n\n\ndisplay-name\n\n\n\n\nA human readable name that describes this datapath. It can be anything you want.\n\n\n\n\ndpid\n\n\n\n\nThe datapath ID specified in \n/etc/sysconfig/network-scripts/ifcfg-br0\n\n\n\n\nnode-id\n\n\n\n\nThe ID of the VNA that will manage this datapath. You can find this ID written in \n/etc/openvnet/vna.conf\n. In a production environment, it's very likely for OpenVNet to span multiple hosts, each with their own Open vSwitch and VNA combo. Therefore we need to tell OpenVNet which VNA will manage which datapath.",
            "title": "datapaths"
        },
        {
            "location": "/vnctl/datapaths/#datapaths-add",
            "text": "This page explains the arguments used by the  vnctl datapaths add  command in the  installation guide ).  vnctl datapaths add \\\n --uuid dp-test1 \\\n --display-name test1 \\\n --dpid 0x0000aaaaaaaaaaaa \\\n --node-id vna   uuid   A unique ID that will be used to refer to this datapath.   display-name   A human readable name that describes this datapath. It can be anything you want.   dpid   The datapath ID specified in  /etc/sysconfig/network-scripts/ifcfg-br0   node-id   The ID of the VNA that will manage this datapath. You can find this ID written in  /etc/openvnet/vna.conf . In a production environment, it's very likely for OpenVNet to span multiple hosts, each with their own Open vSwitch and VNA combo. Therefore we need to tell OpenVNet which VNA will manage which datapath.",
            "title": "datapaths add"
        },
        {
            "location": "/vnctl/interfaces/",
            "text": "interfaces add\n\n\nThis page explains the arguments used by the \nvnctl interfaces add\n command in the \nSingle network\n) guide.\n\n\nvnctl interfaces add \\\n  --uuid if-inst1 \\\n  --mode vif \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 10:54:ff:00:00:01 \\\n  --network-uuid nw-test1 \\\n  --ipv4-address 10.100.0.10 \\\n  --port-name inst1\n\n\n\n\n\n\nuuid\n\n\n\n\nA unique ID that will be used to refer to this interface.\n\n\n\n\nmode\n\n\n\n\nThe mode of the interface. An entry with \nvif\n mode is basically means that this is a network interface that will be connected to one of OpenVNet's virtual networks.\n\n\n\n\nowner-datapath-uuid\n\n\n\n\nThe UUID of the datapath to which this interface will be connected. We created this datapath back in the \ninstallation guide\n.\n\n\n\n\nmac-address\n\n\n\n\nThe MAC address of the network interface of the virtual machine.\n\n\n\n\nnetwork-uuid\n\n\n\n\nThe UUID of the virtual network to participate\n\n\n\n\nipv4-address\n\n\n\n\nThe IPv4 address which will be assigned to the network interface.\n\n\n\n\nport-name\n\n\n\n\nTypically there are multiple network interfaces connected to Open vSwitch. OpenVNet needs to know which one we are describing here. That's where \nport-name\n comes in. This needs to be the same as this interface's port name on Open vSwitch. You can see the ports currently connected to Open vSwitch by running \novs-vsctl show\n.",
            "title": "interfaces"
        },
        {
            "location": "/vnctl/interfaces/#interfaces-add",
            "text": "This page explains the arguments used by the  vnctl interfaces add  command in the  Single network ) guide.  vnctl interfaces add \\\n  --uuid if-inst1 \\\n  --mode vif \\\n  --owner-datapath-uuid dp-test1 \\\n  --mac-address 10:54:ff:00:00:01 \\\n  --network-uuid nw-test1 \\\n  --ipv4-address 10.100.0.10 \\\n  --port-name inst1   uuid   A unique ID that will be used to refer to this interface.   mode   The mode of the interface. An entry with  vif  mode is basically means that this is a network interface that will be connected to one of OpenVNet's virtual networks.   owner-datapath-uuid   The UUID of the datapath to which this interface will be connected. We created this datapath back in the  installation guide .   mac-address   The MAC address of the network interface of the virtual machine.   network-uuid   The UUID of the virtual network to participate   ipv4-address   The IPv4 address which will be assigned to the network interface.   port-name   Typically there are multiple network interfaces connected to Open vSwitch. OpenVNet needs to know which one we are describing here. That's where  port-name  comes in. This needs to be the same as this interface's port name on Open vSwitch. You can see the ports currently connected to Open vSwitch by running  ovs-vsctl show .",
            "title": "interfaces add"
        },
        {
            "location": "/vnctl/networks/",
            "text": "networks add\n\n\nvnctl networks add \\\n  --uuid nw-test1 \\\n  --display-name testnet1 \\\n  --ipv4-network 10.100.0.0 \\\n  --ipv4-prefix 24 \\\n  --network-mode virtual\n\n\n\n\n\n\nuuid\n\n\n\n\nA unique ID that will be used to refer to this network.\n\n\n\n\ndisplay-name\n\n\n\n\nA human readable name that describes this network. It can be anything you want.\n\n\n\n\nipv4-network\n\n\n\n\nThe IPv4 network address. Basically the first part (before the slash) of a CIDR notation. For \n10.0.0.0/8\n the network address would be \n10.0.0.0\n.\n\n\n\n\nipv4-prefix (default 24)\n\n\n\n\nThe IPv4 network prefix. The part after the slash of a CIDR notation. For \n10.0.0.0/8\n, the prefix would be 8.\n\n\n\n\nnetwork-mode\n\n\n\n\nThe mode of the network to create. In the example we are creating a virtual network to connect virtual machines to. Therefore we specify \nvirtual\n.\n\n\nIf we were to be creating a network that OpenVNet will use behind the scenes to send traffic between different hosts running Open vSwitch, we would specify \nphysical\n instead.",
            "title": "networks"
        },
        {
            "location": "/vnctl/networks/#networks-add",
            "text": "vnctl networks add \\\n  --uuid nw-test1 \\\n  --display-name testnet1 \\\n  --ipv4-network 10.100.0.0 \\\n  --ipv4-prefix 24 \\\n  --network-mode virtual   uuid   A unique ID that will be used to refer to this network.   display-name   A human readable name that describes this network. It can be anything you want.   ipv4-network   The IPv4 network address. Basically the first part (before the slash) of a CIDR notation. For  10.0.0.0/8  the network address would be  10.0.0.0 .   ipv4-prefix (default 24)   The IPv4 network prefix. The part after the slash of a CIDR notation. For  10.0.0.0/8 , the prefix would be 8.   network-mode   The mode of the network to create. In the example we are creating a virtual network to connect virtual machines to. Therefore we specify  virtual .  If we were to be creating a network that OpenVNet will use behind the scenes to send traffic between different hosts running Open vSwitch, we would specify  physical  instead.",
            "title": "networks add"
        },
        {
            "location": "/vnctl/filters/",
            "text": "Filters\n\n\nOpenVNet supports filter rules which can be used to restrict incoming/outgoing traffic for specific interfaces.\n\n\nfilters add\n\n\nThis page explains how to use the filter command.\n\n\nvnctl filters add \\\n--interface-uuid if-inst1 \\\n--mode static \\\n--ingress-passthrough false \\\n--egress-passthrough false \\\n\n\n\n\n\n\ninterface-uuid\n\n\n\n\nThe interface for which the filter will be applied.\n\n\n\n\nmode\n\n\n\n\nThe type of filtering mode we want to used. Currently we only support static filtering, which opens/closes a port to a ip address for a specified protocol.\n\n\n\n\ningress-passthrough\n\n\n\n\nA flag that decides whether to drop or allow incoming traffic for matches with no static rule. The default setting is \nfalse\n.\n\n\n\n\negress-passthrough\n\n\n\n\nA flag that decides whether to drop or allow outgoing traffic for matches with no static rule. The default setting is \nfalse\n.\n\n\nfilters static\n\n\nvnctl filters static add fil-test \\\n--protocol tcp \\\n--ipv4-address 10.0.0.1 \\\n--port-number 21 \\\n--passthrough\n\n\n\n\nHere we create a simple rule that opens up traffic for the tcp protocol on port 21.\n\n\n\n\nprotocol\n\n\n\n\nThe protocol which we filter our traffic on.\n\n\n\n\nipv4-address\n\n\n\n\nThe ip address for the rule. 0.0.0.0/0 will match all ip addresses.\n\n\n\n\nport-number\n\n\n\n\nSets port number to open/close when filtering tcp or udp traffic. 0 will match all ports.\n\n\n\n\npassthrough\n\n\n\n\nA flag that decides whether to drop or allow traffic when the src/dst matches the rule. The default setting is \ntrue\n.",
            "title": "filters"
        },
        {
            "location": "/vnctl/filters/#filters",
            "text": "OpenVNet supports filter rules which can be used to restrict incoming/outgoing traffic for specific interfaces.",
            "title": "Filters"
        },
        {
            "location": "/vnctl/filters/#filters-add",
            "text": "This page explains how to use the filter command.  vnctl filters add \\\n--interface-uuid if-inst1 \\\n--mode static \\\n--ingress-passthrough false \\\n--egress-passthrough false \\   interface-uuid   The interface for which the filter will be applied.   mode   The type of filtering mode we want to used. Currently we only support static filtering, which opens/closes a port to a ip address for a specified protocol.   ingress-passthrough   A flag that decides whether to drop or allow incoming traffic for matches with no static rule. The default setting is  false .   egress-passthrough   A flag that decides whether to drop or allow outgoing traffic for matches with no static rule. The default setting is  false .",
            "title": "filters add"
        },
        {
            "location": "/vnctl/filters/#filters-static",
            "text": "vnctl filters static add fil-test \\\n--protocol tcp \\\n--ipv4-address 10.0.0.1 \\\n--port-number 21 \\\n--passthrough  Here we create a simple rule that opens up traffic for the tcp protocol on port 21.   protocol   The protocol which we filter our traffic on.   ipv4-address   The ip address for the rule. 0.0.0.0/0 will match all ip addresses.   port-number   Sets port number to open/close when filtering tcp or udp traffic. 0 will match all ports.   passthrough   A flag that decides whether to drop or allow traffic when the src/dst matches the rule. The default setting is  true .",
            "title": "filters static"
        },
        {
            "location": "/community/",
            "text": "Contribute\n\n\nThis article is about contributing documentation. \n\n\nIf you wish to contribute to this website, you will need to have a \nGithub\n account and be familiar with \nGit\n. You can contribute using Github's \nfork & pull\n system. We will review your contributions and possibly ask you to change around a few things.\n\n\nThis will not be a one-way conversation. We welcome (well argumented and respectful) discussions about what the documentation should be like. Once we're satisfied with your contribution, we will merge it and publish it to the main website.\n\n\nThis site's development repository is located here in the docs folder: \nhttps://github.com/axsh/openvnet\n\n\nTip:\n If you want to preview your changes locally, try running \nmkdocs\n.",
            "title": "Community"
        },
        {
            "location": "/community/#contribute",
            "text": "This article is about contributing documentation.   If you wish to contribute to this website, you will need to have a  Github  account and be familiar with  Git . You can contribute using Github's  fork & pull  system. We will review your contributions and possibly ask you to change around a few things.  This will not be a one-way conversation. We welcome (well argumented and respectful) discussions about what the documentation should be like. Once we're satisfied with your contribution, we will merge it and publish it to the main website.  This site's development repository is located here in the docs folder:  https://github.com/axsh/openvnet  Tip:  If you want to preview your changes locally, try running  mkdocs .",
            "title": "Contribute"
        },
        {
            "location": "/jargon-dictionary/",
            "text": "A\n\n\nB\n\n\nC\n\n\nD\n\n\nE\n\n\nF\n\n\nFlow\n\n\nA single rule inside Open vSwitch. When packets traverse trough Open vSwitch, they are matched against flows which then decide what needs to happen with them.\n\n\nG\n\n\nH\n\n\nI\n\n\nJ\n\n\nK\n\n\nL\n\n\nM\n\n\nN\n\n\nO\n\n\nOpenFlow\n\n\nAn open protocol that allows a controller to tell network devices like switches and routers to update their flow tables.\n\n\nhttp://openflow.org\n\n\nOpen vSwitch\n\n\nA virtual switch capable of using \nOpenFlow\n.\n\n\nhttp://openvswitch.org\n\n\nP\n\n\nPhysical network\n\n\n\"Regular\" networks that are not managed by OpenVNet. OpenVNet itself uses physical networks for its processes to communicate.\n\n\nQ\n\n\nR\n\n\nS\n\n\nT\n\n\nTraditional network\n\n\nSee \nphysical network\n.\n\n\nU\n\n\nV\n\n\nVNet Edge\n\n\nA part of OpenVNet that allows traditional networks to be connected to OpenVNet's virtual networks on Layer 2 of the \nOSI model\n.\n\n\nVirtual network\n\n\nA software defined network managed by OpenVNet. These are defined using \nflows\n in \nOpen vSwitch\n.\n\n\nW\n\n\nX\n\n\nY\n\n\nZ",
            "title": "Jargon Dictionary"
        },
        {
            "location": "/jargon-dictionary/#a",
            "text": "",
            "title": "A"
        },
        {
            "location": "/jargon-dictionary/#b",
            "text": "",
            "title": "B"
        },
        {
            "location": "/jargon-dictionary/#c",
            "text": "",
            "title": "C"
        },
        {
            "location": "/jargon-dictionary/#d",
            "text": "",
            "title": "D"
        },
        {
            "location": "/jargon-dictionary/#e",
            "text": "",
            "title": "E"
        },
        {
            "location": "/jargon-dictionary/#f",
            "text": "",
            "title": "F"
        },
        {
            "location": "/jargon-dictionary/#flow",
            "text": "A single rule inside Open vSwitch. When packets traverse trough Open vSwitch, they are matched against flows which then decide what needs to happen with them.",
            "title": "Flow"
        },
        {
            "location": "/jargon-dictionary/#g",
            "text": "",
            "title": "G"
        },
        {
            "location": "/jargon-dictionary/#h",
            "text": "",
            "title": "H"
        },
        {
            "location": "/jargon-dictionary/#i",
            "text": "",
            "title": "I"
        },
        {
            "location": "/jargon-dictionary/#j",
            "text": "",
            "title": "J"
        },
        {
            "location": "/jargon-dictionary/#k",
            "text": "",
            "title": "K"
        },
        {
            "location": "/jargon-dictionary/#l",
            "text": "",
            "title": "L"
        },
        {
            "location": "/jargon-dictionary/#m",
            "text": "",
            "title": "M"
        },
        {
            "location": "/jargon-dictionary/#n",
            "text": "",
            "title": "N"
        },
        {
            "location": "/jargon-dictionary/#o",
            "text": "",
            "title": "O"
        },
        {
            "location": "/jargon-dictionary/#openflow",
            "text": "An open protocol that allows a controller to tell network devices like switches and routers to update their flow tables.  http://openflow.org",
            "title": "OpenFlow"
        },
        {
            "location": "/jargon-dictionary/#open-vswitch",
            "text": "A virtual switch capable of using  OpenFlow .  http://openvswitch.org",
            "title": "Open vSwitch"
        },
        {
            "location": "/jargon-dictionary/#p",
            "text": "",
            "title": "P"
        },
        {
            "location": "/jargon-dictionary/#physical-network",
            "text": "\"Regular\" networks that are not managed by OpenVNet. OpenVNet itself uses physical networks for its processes to communicate.",
            "title": "Physical network"
        },
        {
            "location": "/jargon-dictionary/#q",
            "text": "",
            "title": "Q"
        },
        {
            "location": "/jargon-dictionary/#r",
            "text": "",
            "title": "R"
        },
        {
            "location": "/jargon-dictionary/#s",
            "text": "",
            "title": "S"
        },
        {
            "location": "/jargon-dictionary/#t",
            "text": "",
            "title": "T"
        },
        {
            "location": "/jargon-dictionary/#traditional-network",
            "text": "See  physical network .",
            "title": "Traditional network"
        },
        {
            "location": "/jargon-dictionary/#u",
            "text": "",
            "title": "U"
        },
        {
            "location": "/jargon-dictionary/#v",
            "text": "",
            "title": "V"
        },
        {
            "location": "/jargon-dictionary/#vnet-edge",
            "text": "A part of OpenVNet that allows traditional networks to be connected to OpenVNet's virtual networks on Layer 2 of the  OSI model .",
            "title": "VNet Edge"
        },
        {
            "location": "/jargon-dictionary/#virtual-network",
            "text": "A software defined network managed by OpenVNet. These are defined using  flows  in  Open vSwitch .",
            "title": "Virtual network"
        },
        {
            "location": "/jargon-dictionary/#w",
            "text": "",
            "title": "W"
        },
        {
            "location": "/jargon-dictionary/#x",
            "text": "",
            "title": "X"
        },
        {
            "location": "/jargon-dictionary/#y",
            "text": "",
            "title": "Y"
        },
        {
            "location": "/jargon-dictionary/#z",
            "text": "",
            "title": "Z"
        }
    ]
}