{
    "docs": [
        {
            "location": "/",
            "text": "What is OpenVNet?\n\n\nOpenVNet is what you would call a network hypervisor. A network hypervisor provides a layer of abstraction on top of existing network hardware. Network engineers become able to create any network topology that they have in mind, without taking the existing hardware into account.\n\n\nOpenVNet is free open source software. The source is \nfreely available on Github\n. Everybody is welcome to contribute to development and the software can be freely distributed. (Within the rules of the LGPL license)\n\n\nGetting started\n\n\nInstallation Guide\n\n\nThis guide will teach you how to set up the most basic OpenVNet environment possible which is just two VMs on the same host connected to \nOpen vSwitch\n. While this environment doesn't do anything you couldn't do with a basic Linux Bridge, it is a great entry point into the world of OpenVNet.\n\n\nWe hope to get more expansive guides up in the future. Until then we encourage you to play around and contact us for assistance if needed.\n\n\nContact us\n\n\nThe best way to contact us is to send an e-mail to the \nWakame Users Group\n on Google Groups. Please don't hesitate to ask us any questions. We realise OpenVNet is difficult to set up and that our documentation is limited at this time. If you want to try it out, we'll do our best to help you.\n\n\nIf you happen to be in Tokyo, you can also attend one of our Wakame Users Group events. They are open to everybody. Further details on http://wakameusersgroup.org.",
            "title": "Home"
        },
        {
            "location": "/#what-is-openvnet",
            "text": "OpenVNet is what you would call a network hypervisor. A network hypervisor provides a layer of abstraction on top of existing network hardware. Network engineers become able to create any network topology that they have in mind, without taking the existing hardware into account.  OpenVNet is free open source software. The source is  freely available on Github . Everybody is welcome to contribute to development and the software can be freely distributed. (Within the rules of the LGPL license)",
            "title": "What is OpenVNet?"
        },
        {
            "location": "/#getting-started",
            "text": "Installation Guide  This guide will teach you how to set up the most basic OpenVNet environment possible which is just two VMs on the same host connected to  Open vSwitch . While this environment doesn't do anything you couldn't do with a basic Linux Bridge, it is a great entry point into the world of OpenVNet.  We hope to get more expansive guides up in the future. Until then we encourage you to play around and contact us for assistance if needed.",
            "title": "Getting started"
        },
        {
            "location": "/#contact-us",
            "text": "The best way to contact us is to send an e-mail to the  Wakame Users Group  on Google Groups. Please don't hesitate to ask us any questions. We realise OpenVNet is difficult to set up and that our documentation is limited at this time. If you want to try it out, we'll do our best to help you.  If you happen to be in Tokyo, you can also attend one of our Wakame Users Group events. They are open to everybody. Further details on http://wakameusersgroup.org.",
            "title": "Contact us"
        },
        {
            "location": "/installation/",
            "text": "OpenVNet Installation Guide\n\n\nOverview\n\n\nWelcome to the world of OpenVNet! With this installation guide we help you\ncreate a very simple yet innovative virtual network environment.\n\n\n\n\nOn a given server (here named as server1) there is one virtual network whose network address is 10.100.0.0/24 and 2 virtual machines joining it.\nThe orange circles describe OpenVNet's ruby processes; vna, vnmgr and webapi.\nSee architecture for more details of how the OpenVNet works.\n\n\nRequirements\n\n\n\n\nRuby 2.1.1\n\n\nCentOS 6.6\n\n\nOpen vSwitch 2.3.1\n\n\nInternet connection\n\n\n\n\nInstallation\n\n\nInstall OpenVNet Packages\n\n\nDownload the openvnet.repo file and put it to your \n/etc/yum.repos.d/\n directory.\n\n\ncurl -o /etc/yum.repos.d/openvnet.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet.repo\n\n\n\n\nDownload the openvnet-third-party.repo file and put it in your \n/etc/yum.repos.d/\n directory.\n\n\ncurl -o /etc/yum.repos.d/openvnet-third-party.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet-third-party.repo\n\n\n\n\nEach repo has the following packages:\n\n\n\n\nopenvnet.repo\n\n\nopenvnet (metapackage)\n\n\nopenvnet-common\n\n\nopenvnet-vna\n\n\nopenvnet-vnmgr\n\n\nopenvnet-webapi\n\n\n\n\nopenvnet-vnctl\n\n\n\n\n\n\nopenvnet-third-party.repo\n\n\n\n\nopenvnet-ruby\n\n\nopenvswitch\n\n\n\n\nInstall epel-release.\n\n\nyum install -y epel-release\n\n\n\n\nInstall OpenVNet packages.\n\n\nyum install -y openvnet\n\n\n\n\nopenvnet\n is a metapackage. It is equivalent to installing \nopenvnet-common\n,\n\nopenvnet-vna\n, \nopenvnet-vnmgr\n, \nopenvnet-webapi\n, \nopenvnet-vnctl\n at once.\n\n\nInstall \nRedis\n and \nMySQL server\n. Redis is required for OpenVNet's processes to communicate and MySQL for data storage. Though they're both required, they are not package dependencies because OpenVNet is distributed software. In a production environment, it is very likely for these packages to be installed on other machines than the OpenVNet processes themselves.\n\n\nyum install -y mysql-server redis\n\n\n\n\nEdit Configuration Files\n\n\nEdit the file \n/etc/openvnet/vnmgr.conf\n\n\nnode {\n  id \"vnmgr\"\n  addr {\n    protocol \"tcp\"\n    host \"127.0.0.1\"\n    public \"\"\n    port 9102\n  }\n}\n\n\n\nModify the parameters \nhost\n and \npublic\n according to your environment. In order for\nthe sample environment in the overview section we leave those parameters as is. The detail of each parameter is following.\n\n\n\n\n\n\nid\n : OpenVNet relies on the \n0mq\n protocol for communication among its processes. Hereby processes means vnmgr, vna and webapi. This id is used by 0mq to identify each process. Any string here is fine as long as there's no collision in OpenVNet. It's recommended to just use the default values.\n\n\n\n\n\n\nprotocol\n : The layer 4 protocol which is either TCP or UDP. A socket which the 0mq needs will be created based on this parameter. The default value is \ntcp\n.\n\n\n\n\n\n\nhost\n : The IP address of the vnmgr node. We use loopback address in this guide because all the processes reside on the same node .\n\n\n\n\n\n\npublic\n : In case the process running in a NAT environment, specify the NAT address as the process can be reached from the outside of the NAT environment.\n\n\n\n\n\n\nport\n : The port number that the process will listen to. Specify a unique port number and make sure the port number is different for each of the OpenVNet's processes and also not taken by any other process.\n\n\n\n\n\n\n/etc/openvnet/vna.conf\n and \n/etc/openvnet/webapi.conf\n have the same structure as \nvnmgr.conf\n. Edit them if necessary otherwise leave them as is for the sample environment we are just creating. We need the \nid\n parameter in \nvna.conf\n later when we configure the database. Please make sure what you specified.\n\n\nSetup Local Infrastructure\n\n\nDatapath is one of the Linux kernel capabilities behaving similar to the Linux bridge.\nCreate the file \n/etc/sysconfig/network-scripts/ifcfg-br0\n with the following contents. However you need to pay attention to several parameters.\n\n\n\n\ndatapath-id\n\n\n\n\nThe datapath ID that the Open vSwitch will use. Set unique 16 hex digits as you like.\n\n\nDEVICE=br0\nDEVICETYPE=ovs\nTYPE=OVSBridge\nONBOOT=yes\nBOOTPROTO=static\nHOTPLUG=no\nOVS_EXTRA=\n\n set bridge     ${DEVICE} protocols=OpenFlow10,OpenFlow12,OpenFlow13 --\n set bridge     ${DEVICE} other_config:disable-in-band=true --\n set bridge     ${DEVICE} other-config:datapath-id=0000aaaaaaaaaaaa --\n set bridge     ${DEVICE} other-config:hwaddr=02:01:00:00:00:01 --\n set-fail-mode  ${DEVICE} standalone --\n set-controller ${DEVICE} tcp:127.0.0.1:6633\n\n\n\n\n\n\nStart \nopenvswitch\n service and \nifup\n the datapath.\n\n\nservice openvswitch start\nifup br0\n\n\n\n\nStart redis\n\n\nservice redis start\n\n\n\n\nSetup Database\n\n\nEdit \n/etc/openvnet/common.conf\n if necessary. The sample environment uses the default settings.\n\n\nLaunch MySQL server.\n\n\nservice mysqld start\n\n\n\n\nTo automatically launch the MySQL server at boot, execute the following command.\n\n\nchkconfig mysqld on\n\n\n\n\nSet \nPATH\n environment variable as following since the OpenVNet uses its own ruby binary.\n\n\nPATH=/opt/axsh/openvnet/ruby/bin:${PATH}\n\n\n\n\nCreate database\n\n\ncd /opt/axsh/openvnet/vnet\nbundle exec rake db:create\nbundle exec rake db:init\n\n\n\n\nStart vnmgr and webapi.\n\n\ninitctl start vnet-vnmgr\ninitctl start vnet-webapi\n\n\n\n\nWe use \nvnctl\n to create the database records subsequent to the above configurations. \nvnctl\n is Web API client offered by the \nopenvnet-vnctl\n package.\n\n\nDatapath\n\n\nWe created a datapath earlier that the OpenVNet needs to know. The following database record must be created in order to tell the OpenVNet about the datapath.\n\n\nvnctl datapaths add --uuid dp-test1 --display-name test1 --dpid 0x0000aaaaaaaaaaaa --node-id vna\n\n\n\n\n\n\ndpid\n\n\n\n\nThe datapath ID specified in \n/etc/sysconfig/network-scripts/ifcfg-br0\n\n\n\n\nnode-id\n\n\n\n\nThe ID of the vna written in \n/etc/openvnet/vna.conf\n\n\nNetwork\n\n\nIn the figure of the sample environment there is a light purple circle which represents a virtual network. You need to define the virtual network by \nvnctl networks add\n subcommand with the following parameters.\n\n\nvnctl networks add --uuid nw-test1 --display-name testnet1 --ipv4-network 10.100.0.0 --ipv4-prefix 24 --network-mode virtual\n\n\n\n\n\n\nipv4-network\n\n\n\n\nThe IPv4 network address.\n\n\n\n\nipv4-prefix\n\n\n\n\nThe IPv4 network prefix. (default 24)\n\n\n\n\nnetwork-mode\n\n\n\n\nThe mode of the network to create. We are currently creating the virtual network (10.100.0.0/24) mentioned in the figure. That is why we specify \nvirtual\n here.\n\n\nInterface\n\n\nAs the sample environment has 2 virtual machines, here we define 2 database records of interface. These records will be associated to the tap interfaces of the virtual machines. The former record contains \ninst1\n's network interface information. The latter is for \ninst2\n.\n\n\nvnctl interfaces add --uuid if-inst1 --mode vif --owner-datapath-uuid dp-test1 --mac-address 10:54:ff:00:00:01 --network-uuid nw-test1 --ipv4-address 10.100.0.10 --port-name inst1\nvnctl interfaces add --uuid if-inst2 --mode vif --owner-datapath-uuid dp-test1 --mac-address 10:54:ff:00:00:02 --network-uuid nw-test1 --ipv4-address 10.100.0.11 --port-name inst2\n\n\n\n\n\n\nmode\n\n\n\n\nThe mode of the interface. An entry with \nvif\n mode is basically for a virtual or physical device that is attached to the datapath of the Open vSwitch. Another mode might be specified for a physical device but here we omit the explanation about it.\n\n\n\n\nowner-datapath-uuid\n\n\n\n\nThe UUID of the datapath to which this interface will be connected.\n\n\n\n\nmac-address\n\n\n\n\nThe MAC address of the network interface of the virtual machine.\n\n\n\n\nnetwork-uuid\n\n\n\n\nThe UUID of the virtual network to participate\n\n\n\n\nipv4-address\n\n\n\n\nThe IPv4 address which will be assigned to the network interface.\n\n\n\n\nport-name\n\n\n\n\nThe OpenVNet associates an Open vSwitch's port with a database record of the interface table if its \nport-name\n is corresponded to what you can see by \novs-vsctl show\n.\n\n\nLaunch Services\n\n\nThe OpenVNet's processes(vnmgr, webapi and vna) are registered as upstart jobs.\nYou can launch them using the following commands. vnmgr and webapi may have already been launched in the last sections.\n\n\ninitctl start vnet-vnmgr\ninitctl start vnet-webapi\ninitctl start vnet-vna\n\n\n\n\nThe log files are created in the /var/log/openvnet directory. Refer to them if something bad happens. If the vna is successfully launched you can see \nis_connected: true\n by \novs-vsctl show\n such as following.\n\n\nfbe23184-7f14-46cb-857b-3abf6153a6d6\n    Bridge \nbr0\n\n        Controller \ntcp:127.0.0.1:6633\n\n            is_connected: true\n\n\n\n\nThis means the OpenFlow controller which is vna is now connected to the datapath. After the connection between the OpenFlow controller and the\ndatapath is established it starts installing the flows on the datapath.\n\n\nVerification\n\n\nBy following all the instructions from the beginning to this section, you already have the sample environment. In this section, we are firstly going to play around the environment then secondary see network packets going through OpenFlow rules to reach\nfrom one guest to another.\n\n\nAs a representation of the guest here we use \nLXC\n, which helps users run multiple isolated Linux system containers. Any other virtualization technologies might be used, however we take LXC since it is easy to create/destroy/configure and simple enough to do this verification.\n\n\nInstall LXC\n\n\nyum -y install lxc lxc-templates\n\n\n\n\nCreate and mount cgroup\n\n\nmkdir /cgroup\necho \ncgroup /cgroup cgroup defaults 0 0\n \n /etc/fstab\nmount /cgroup\n\n\n\n\nCreate 2 LXC guests. Rsync is required for this. If it's not installed already, install it with the following command.\n\n\nyum install -y rsync\n\n\n\n\nlxc-create -t centos -n inst1\nlxc-create -t centos -n inst2\n\n\n\n\nConfigure interfaces of each guest\n\n\nvi /var/lib/lxc/inst1/config\n\nlxc.network.type = veth\nlxc.network.flags = up\nlxc.network.veth.pair = inst1\nlxc.network.ipv4 = 10.100.0.10\nlxc.network.hwaddr = 10:54:FF:00:00:01\nlxc.rootfs = /var/lib/lxc/inst1/rootfs\nlxc.include = /usr/share/lxc/config/centos.common.conf\nlxc.arch = x86_64\nlxc.utsname = inst1\nlxc.autodev = 0\n\n\n\n\nvi /var/lib/lxc/inst2/config\n\nlxc.network.type = veth\nlxc.network.flags = up\nlxc.network.veth.pair = inst2\nlxc.network.ipv4 = 10.100.0.11\nlxc.network.hwaddr = 10:54:FF:00:00:02\nlxc.rootfs = /var/lib/lxc/inst2/rootfs\nlxc.include = /usr/share/lxc/config/centos.common.conf\nlxc.arch = x86_64\nlxc.utsname = inst2\nlxc.autodev = 0\n\n\n\n\nWe do not use \nlxc.network.link\n parameter because the Linux bridge is replaced by the Open vSwitch.\n\n\nMake sure that the IPv4 address and MAC address are the same as what you specify when you create the interface database records.\n\n\nLaunch the LXC guests then enslave the LXC's tap interfaces to the datapath.\n\n\nlxc-start -d -n inst1\nlxc-start -d -n inst2\n\novs-vsctl add-port br0 inst1\novs-vsctl add-port br0 inst2\n\n\n\n\nNow the LXC's network interfaces are attached to the Open vSwitch, likewise you plug a LAN cable to a network switch.\n\n\nLog in to the inst1 to see if the IP address is assigned properly.\n\n\nlxc-console -n inst1\nip a\n\n\n\n\nping to inst2 (10.100.0.11)\n\n\nping 10.100.0.11\n\n\n\n\nYou would see the ping reply from the peer machine (in this case inst2). Meanwhile you can see which flows are selected by \nvnflows-monitor\n. Execute the following command on a lxc guest, then ping from one another.\n\n\ncd /opt/axsh/openvnet/vnet/bin\n./vnflows-monitor -d -c 0\n\n\n\n\nYou can see all the flows by calling \nvnflows-monitor\n without arguments.\n\n\ncd /opt/axsh/openvnet/vnet/bin\n./vnflows-monitor",
            "title": "Installation"
        },
        {
            "location": "/installation/#openvnet-installation-guide",
            "text": "",
            "title": "OpenVNet Installation Guide"
        },
        {
            "location": "/installation/#overview",
            "text": "Welcome to the world of OpenVNet! With this installation guide we help you\ncreate a very simple yet innovative virtual network environment.   On a given server (here named as server1) there is one virtual network whose network address is 10.100.0.0/24 and 2 virtual machines joining it.\nThe orange circles describe OpenVNet's ruby processes; vna, vnmgr and webapi.\nSee architecture for more details of how the OpenVNet works.",
            "title": "Overview"
        },
        {
            "location": "/installation/#requirements",
            "text": "Ruby 2.1.1  CentOS 6.6  Open vSwitch 2.3.1  Internet connection",
            "title": "Requirements"
        },
        {
            "location": "/installation/#installation",
            "text": "Install OpenVNet Packages  Download the openvnet.repo file and put it to your  /etc/yum.repos.d/  directory.  curl -o /etc/yum.repos.d/openvnet.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet.repo  Download the openvnet-third-party.repo file and put it in your  /etc/yum.repos.d/  directory.  curl -o /etc/yum.repos.d/openvnet-third-party.repo -R https://raw.githubusercontent.com/axsh/openvnet/master/deployment/yum_repositories/stable/openvnet-third-party.repo  Each repo has the following packages:   openvnet.repo  openvnet (metapackage)  openvnet-common  openvnet-vna  openvnet-vnmgr  openvnet-webapi   openvnet-vnctl    openvnet-third-party.repo   openvnet-ruby  openvswitch   Install epel-release.  yum install -y epel-release  Install OpenVNet packages.  yum install -y openvnet  openvnet  is a metapackage. It is equivalent to installing  openvnet-common , openvnet-vna ,  openvnet-vnmgr ,  openvnet-webapi ,  openvnet-vnctl  at once.  Install  Redis  and  MySQL server . Redis is required for OpenVNet's processes to communicate and MySQL for data storage. Though they're both required, they are not package dependencies because OpenVNet is distributed software. In a production environment, it is very likely for these packages to be installed on other machines than the OpenVNet processes themselves.  yum install -y mysql-server redis  Edit Configuration Files  Edit the file  /etc/openvnet/vnmgr.conf  node {\n  id \"vnmgr\"\n  addr {\n    protocol \"tcp\"\n    host \"127.0.0.1\"\n    public \"\"\n    port 9102\n  }\n}  Modify the parameters  host  and  public  according to your environment. In order for\nthe sample environment in the overview section we leave those parameters as is. The detail of each parameter is following.    id  : OpenVNet relies on the  0mq  protocol for communication among its processes. Hereby processes means vnmgr, vna and webapi. This id is used by 0mq to identify each process. Any string here is fine as long as there's no collision in OpenVNet. It's recommended to just use the default values.    protocol  : The layer 4 protocol which is either TCP or UDP. A socket which the 0mq needs will be created based on this parameter. The default value is  tcp .    host  : The IP address of the vnmgr node. We use loopback address in this guide because all the processes reside on the same node .    public  : In case the process running in a NAT environment, specify the NAT address as the process can be reached from the outside of the NAT environment.    port  : The port number that the process will listen to. Specify a unique port number and make sure the port number is different for each of the OpenVNet's processes and also not taken by any other process.    /etc/openvnet/vna.conf  and  /etc/openvnet/webapi.conf  have the same structure as  vnmgr.conf . Edit them if necessary otherwise leave them as is for the sample environment we are just creating. We need the  id  parameter in  vna.conf  later when we configure the database. Please make sure what you specified.  Setup Local Infrastructure  Datapath is one of the Linux kernel capabilities behaving similar to the Linux bridge.\nCreate the file  /etc/sysconfig/network-scripts/ifcfg-br0  with the following contents. However you need to pay attention to several parameters.   datapath-id   The datapath ID that the Open vSwitch will use. Set unique 16 hex digits as you like.  DEVICE=br0\nDEVICETYPE=ovs\nTYPE=OVSBridge\nONBOOT=yes\nBOOTPROTO=static\nHOTPLUG=no\nOVS_EXTRA= \n set bridge     ${DEVICE} protocols=OpenFlow10,OpenFlow12,OpenFlow13 --\n set bridge     ${DEVICE} other_config:disable-in-band=true --\n set bridge     ${DEVICE} other-config:datapath-id=0000aaaaaaaaaaaa --\n set bridge     ${DEVICE} other-config:hwaddr=02:01:00:00:00:01 --\n set-fail-mode  ${DEVICE} standalone --\n set-controller ${DEVICE} tcp:127.0.0.1:6633   Start  openvswitch  service and  ifup  the datapath.  service openvswitch start\nifup br0  Start redis  service redis start  Setup Database  Edit  /etc/openvnet/common.conf  if necessary. The sample environment uses the default settings.  Launch MySQL server.  service mysqld start  To automatically launch the MySQL server at boot, execute the following command.  chkconfig mysqld on  Set  PATH  environment variable as following since the OpenVNet uses its own ruby binary.  PATH=/opt/axsh/openvnet/ruby/bin:${PATH}  Create database  cd /opt/axsh/openvnet/vnet\nbundle exec rake db:create\nbundle exec rake db:init  Start vnmgr and webapi.  initctl start vnet-vnmgr\ninitctl start vnet-webapi  We use  vnctl  to create the database records subsequent to the above configurations.  vnctl  is Web API client offered by the  openvnet-vnctl  package.  Datapath  We created a datapath earlier that the OpenVNet needs to know. The following database record must be created in order to tell the OpenVNet about the datapath.  vnctl datapaths add --uuid dp-test1 --display-name test1 --dpid 0x0000aaaaaaaaaaaa --node-id vna   dpid   The datapath ID specified in  /etc/sysconfig/network-scripts/ifcfg-br0   node-id   The ID of the vna written in  /etc/openvnet/vna.conf  Network  In the figure of the sample environment there is a light purple circle which represents a virtual network. You need to define the virtual network by  vnctl networks add  subcommand with the following parameters.  vnctl networks add --uuid nw-test1 --display-name testnet1 --ipv4-network 10.100.0.0 --ipv4-prefix 24 --network-mode virtual   ipv4-network   The IPv4 network address.   ipv4-prefix   The IPv4 network prefix. (default 24)   network-mode   The mode of the network to create. We are currently creating the virtual network (10.100.0.0/24) mentioned in the figure. That is why we specify  virtual  here.  Interface  As the sample environment has 2 virtual machines, here we define 2 database records of interface. These records will be associated to the tap interfaces of the virtual machines. The former record contains  inst1 's network interface information. The latter is for  inst2 .  vnctl interfaces add --uuid if-inst1 --mode vif --owner-datapath-uuid dp-test1 --mac-address 10:54:ff:00:00:01 --network-uuid nw-test1 --ipv4-address 10.100.0.10 --port-name inst1\nvnctl interfaces add --uuid if-inst2 --mode vif --owner-datapath-uuid dp-test1 --mac-address 10:54:ff:00:00:02 --network-uuid nw-test1 --ipv4-address 10.100.0.11 --port-name inst2   mode   The mode of the interface. An entry with  vif  mode is basically for a virtual or physical device that is attached to the datapath of the Open vSwitch. Another mode might be specified for a physical device but here we omit the explanation about it.   owner-datapath-uuid   The UUID of the datapath to which this interface will be connected.   mac-address   The MAC address of the network interface of the virtual machine.   network-uuid   The UUID of the virtual network to participate   ipv4-address   The IPv4 address which will be assigned to the network interface.   port-name   The OpenVNet associates an Open vSwitch's port with a database record of the interface table if its  port-name  is corresponded to what you can see by  ovs-vsctl show .  Launch Services  The OpenVNet's processes(vnmgr, webapi and vna) are registered as upstart jobs.\nYou can launch them using the following commands. vnmgr and webapi may have already been launched in the last sections.  initctl start vnet-vnmgr\ninitctl start vnet-webapi\ninitctl start vnet-vna  The log files are created in the /var/log/openvnet directory. Refer to them if something bad happens. If the vna is successfully launched you can see  is_connected: true  by  ovs-vsctl show  such as following.  fbe23184-7f14-46cb-857b-3abf6153a6d6\n    Bridge  br0 \n        Controller  tcp:127.0.0.1:6633 \n            is_connected: true  This means the OpenFlow controller which is vna is now connected to the datapath. After the connection between the OpenFlow controller and the\ndatapath is established it starts installing the flows on the datapath.",
            "title": "Installation"
        },
        {
            "location": "/installation/#verification",
            "text": "By following all the instructions from the beginning to this section, you already have the sample environment. In this section, we are firstly going to play around the environment then secondary see network packets going through OpenFlow rules to reach\nfrom one guest to another.  As a representation of the guest here we use  LXC , which helps users run multiple isolated Linux system containers. Any other virtualization technologies might be used, however we take LXC since it is easy to create/destroy/configure and simple enough to do this verification.  Install LXC  yum -y install lxc lxc-templates  Create and mount cgroup  mkdir /cgroup\necho  cgroup /cgroup cgroup defaults 0 0    /etc/fstab\nmount /cgroup  Create 2 LXC guests. Rsync is required for this. If it's not installed already, install it with the following command.  yum install -y rsync  lxc-create -t centos -n inst1\nlxc-create -t centos -n inst2  Configure interfaces of each guest  vi /var/lib/lxc/inst1/config\n\nlxc.network.type = veth\nlxc.network.flags = up\nlxc.network.veth.pair = inst1\nlxc.network.ipv4 = 10.100.0.10\nlxc.network.hwaddr = 10:54:FF:00:00:01\nlxc.rootfs = /var/lib/lxc/inst1/rootfs\nlxc.include = /usr/share/lxc/config/centos.common.conf\nlxc.arch = x86_64\nlxc.utsname = inst1\nlxc.autodev = 0  vi /var/lib/lxc/inst2/config\n\nlxc.network.type = veth\nlxc.network.flags = up\nlxc.network.veth.pair = inst2\nlxc.network.ipv4 = 10.100.0.11\nlxc.network.hwaddr = 10:54:FF:00:00:02\nlxc.rootfs = /var/lib/lxc/inst2/rootfs\nlxc.include = /usr/share/lxc/config/centos.common.conf\nlxc.arch = x86_64\nlxc.utsname = inst2\nlxc.autodev = 0  We do not use  lxc.network.link  parameter because the Linux bridge is replaced by the Open vSwitch.  Make sure that the IPv4 address and MAC address are the same as what you specify when you create the interface database records.  Launch the LXC guests then enslave the LXC's tap interfaces to the datapath.  lxc-start -d -n inst1\nlxc-start -d -n inst2\n\novs-vsctl add-port br0 inst1\novs-vsctl add-port br0 inst2  Now the LXC's network interfaces are attached to the Open vSwitch, likewise you plug a LAN cable to a network switch.  Log in to the inst1 to see if the IP address is assigned properly.  lxc-console -n inst1\nip a  ping to inst2 (10.100.0.11)  ping 10.100.0.11  You would see the ping reply from the peer machine (in this case inst2). Meanwhile you can see which flows are selected by  vnflows-monitor . Execute the following command on a lxc guest, then ping from one another.  cd /opt/axsh/openvnet/vnet/bin\n./vnflows-monitor -d -c 0  You can see all the flows by calling  vnflows-monitor  without arguments.  cd /opt/axsh/openvnet/vnet/bin\n./vnflows-monitor",
            "title": "Verification"
        },
        {
            "location": "/community/",
            "text": "Contribute\n\n\nThis article is about contributing documentation. \n\n\nIf you wish to contribute to this website, you will need to have a \nGithub\n account and be familiar with \nGit\n. You can contribute using Github's \nfork \n pull\n system. We will review your contributions and possibly ask you to change around a few things.\n\n\nThis will not be a one-way conversation. We welcome (well argumented and respectful) discussions about what the documentation should be like. Once we're satisfied with your contribution, we will merge it and publish it to the main website.\n\n\nThis site's development repository is located here: \nhttps://github.com/axsh/openvnet\n\n\nTip:\n If you want to preview your changes locally, try running \nmkdocs\n.",
            "title": "Community"
        },
        {
            "location": "/community/#contribute",
            "text": "This article is about contributing documentation.   If you wish to contribute to this website, you will need to have a  Github  account and be familiar with  Git . You can contribute using Github's  fork   pull  system. We will review your contributions and possibly ask you to change around a few things.  This will not be a one-way conversation. We welcome (well argumented and respectful) discussions about what the documentation should be like. Once we're satisfied with your contribution, we will merge it and publish it to the main website.  This site's development repository is located here:  https://github.com/axsh/openvnet  Tip:  If you want to preview your changes locally, try running  mkdocs .",
            "title": "Contribute"
        }
    ]
}